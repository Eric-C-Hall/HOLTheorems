
(* This was a comment in front of split_mdr_events_prob, which now has a      *)
(* comment containing "Inductively prove that P(bs) = P(b_1)P(b_2)...P(b_n)"  *)
(* This was the old method I was planning to use to prove this theorem, but   *)
(* I ended up using a different method instead                                *)
(*                                                                            *)
(* PREVIOUS ATTEMPT:                                                          *)
(* 2. Prove that P(bs, σs, cs) = P(bs)Indicator(σs and cs are valid)          *)
(* 3. Prove that Indicator(σs and cs are valid)                               *)
(*     = P(σ_0)P(σ_1c_1|σ_0b_1)P(σ_2c_2|σ_1b_2)...                            *)
(*                                                                            *)
(* PREVIOUS ATTEMPT:                                                          *)
(* Inductively apply the following steps:                                     *)
(*                                                                            *)
(* Merge P(b_i) into P(σ_0b_1σ_1c_1...b_{i-1}σ_{i-1}c_{i-1})                  *)
(* - If σ_0b_1σ_1c_1...b_{i-1}σ_{i-1}c_{i-1} is invalid, then our             *)
(*   probability on the right is 0, thus applying an intersection to the      *)
(*   event will trivially maintain a probability of zero                      *)
(* - If it is valid, then it is equivalent (by lemma) to the event            *)
(*   b_1b_2b_3..., since the σs and the cs are completely determined by       *)
(*   the bs. Then we can prove independence of the b_i with all previous b_k  *)
(*   in a relatively straightforward way.                                     *)
(*                                                                            *)
(* Merge P(σ_ic_i|σ_{i-1}b_i) into the result.                                *)
(* - If σ_i is the incorrect state that would be arrived at after applying    *)
(*   the bs, then b_i ∩ σ_i ∩ σ_{i-1} = 0, and so both LHS and RHS become     *)
(*   zero. If it is the correct state, then b_i ∩ σ_i ∩ σ_{i-1} =             *)



(* -------------------------------------------------------------------------- *)
(* Not sure what the term is for a function which returns one of its inputs   *)
(* as its output, so I used the term "bi-switch", because the function        *)
(* switches between two of its inputs.                                        *)
(* -------------------------------------------------------------------------- *)
(* -------------------------------------------------------------------------- *)
(* TODO: Remove: obsolete due to addition of argmin library                   *)
(* -------------------------------------------------------------------------- *)
Theorem FOLDR_BISWITCH:
  ∀f h ts.
  (∀x y.  f x y = x ∨ f x y = y) ⇒
  MEM (FOLDR f h ts) (h::ts)
Proof
  rpt strip_tac
  (* Induct over ts. Base case trivial *)
  >> Induct_on ‘ts’
  >- gvs[]
  >> rpt strip_tac
  >> PURE_REWRITE_TAC[FOLDR]
  (* do not expand mem, it creates a messy case structure *)
  >> MEM_DONOTEXPAND_TAC
  >> last_x_assum $ qspecl_then [‘h'’, ‘FOLDR f h ts’] assume_tac
  >> MEM_DOEXPAND_TAC
  >> gvs[]
QED

(* -------------------------------------------------------------------------- *)
(* Probably not widely applicable enough to become a proper theorem           *)
(* -------------------------------------------------------------------------- *)
(* -------------------------------------------------------------------------- *)
(* TODO: Remove: obsolete due to addition of argmin library                   *)
(* -------------------------------------------------------------------------- *)
Theorem MEM_CONS_CONS:
  ∀x l l' ls.
  MEM x (l::l'::ls) ⇔ MEM x (l::ls) ∨ x = l'
Proof
  rpt strip_tac
  >> EQ_TAC
  >- (gvs[]
      >> rpt strip_tac >> gvs[])
  >> rpt strip_tac >> gvs[]
QED

(* -------------------------------------------------------------------------- *)
(* TODO: Remove: obsolete due to addition of argmin library                   *)
(* -------------------------------------------------------------------------- *)
(* -------------------------------------------------------------------------- *)
(* TODO: Write version of this in argmin library                              *)
(* -------------------------------------------------------------------------- *)
Theorem FOLDR_DOMAIN_HELPER:
  ∀f g l ls s.
  (∀x. MEM x (l::ls) ⇒ x ∈ s) ∧
  (∀x y. x ∈ s ∧ y ∈ s ⇒ f x y = g x y ∧ (f x y) ∈ s) ⇒
  FOLDR f l ls = FOLDR g l ls ∧ (FOLDR f l ls) ∈ s
Proof
  Induct_on ‘ls’
  >- gvs[]
  >> rpt gen_tac
  >> rpt disch_tac
  >> MEM_DONOTEXPAND_TAC
  >> gvs[FOLDR]
  >> qsuff_tac ‘FOLDR f l ls = FOLDR g l ls ∧ FOLDR f l ls ∈ s’
  >- (disch_tac
      >> gvs[]
      >> first_assum irule
      >> conj_tac
      >- (MEM_DOEXPAND_TAC
          >> gvs[])
      >> gvs[])
  >> last_assum irule
  >> gvs[]
  >> MEM_DOEXPAND_TAC
  >> gvs[]
  >> rpt strip_tac
  >> gvs[]
QED

(* -------------------------------------------------------------------------- *)
(* TODO: obsolete                                                             *)
(* -------------------------------------------------------------------------- *)
Theorem FOLDR_LEQ:
  ∀s h t (f : α -> infnum).
  MEM s (h::t) ⇒
  f (FOLDR (λx y. if f x ≤ f y then x else y) h t) ≤ f s 
Proof
  rpt strip_tac
  >> Induct_on ‘t’
  >- (rpt strip_tac
      >> gvs[])
  >> rpt strip_tac
  >> MEM_DONOTEXPAND_TAC
  >> Cases_on ‘s = h'’ >> gvs[]
  >- (Cases_on_if_asm >> gvs[]
      >> qmatch_asmsub_abbrev_tac ‘f h' < f v’
      >> gvs[inlt_inlt_F]
     )
  >> qmatch_asmsub_abbrev_tac ‘f v' ≤ f s’
  >> imp_prove
  >- (MEM_DOEXPAND_TAC
      >> with_all_in_goal (PURE_REWRITE_TAC[MEM_CONS_CONS])
      >> MEM_DONOTEXPAND_TAC
      >> gvs[])
  >> gvs[]
  >> Cases_on_if_asm >> gvs[]
  >> metis_tac[inle_TRANS]
QED

(* -------------------------------------------------------------------------- *)
(* TODO: obsolete                                                             *)
(* -------------------------------------------------------------------------- *)
Theorem FOLDR_LEQ_LT:
  ∀s h t (f : α -> infnum).
  MEM s (h::t) ⇒
  f (FOLDR (λx y. if f x < f y then x else y) h t) ≤ f s 
Proof
  rpt strip_tac
  >> Induct_on ‘t’
  >- (rpt strip_tac
      >> gvs[])
  >> rpt strip_tac
  >> MEM_DONOTEXPAND_TAC
  >> Cases_on ‘s = h'’ >> gvs[]
  >- (Cases_on_if_asm >> gvs[]
      >> qmatch_asmsub_abbrev_tac ‘f h' < f v’
      >> gvs[inlt_inlt_F]
     )
  >> qmatch_asmsub_abbrev_tac ‘f v' ≤ f s’
  >> imp_prove
  >- (MEM_DOEXPAND_TAC
      >> with_all_in_goal (PURE_REWRITE_TAC[MEM_CONS_CONS])
      >> MEM_DONOTEXPAND_TAC
      >> gvs[])
  >> gvs[]
  >> Cases_on_if_asm >> gvs[]
  >> metis_tac[inlt_TRANS]
QED

(* -------------------------------------------------------------------------- *)
(* TODO: Remove: obsolete due to addition of argmin library                   *)
(* -------------------------------------------------------------------------- *)
(* -------------------------------------------------------------------------- *)
(* TODO: Write version of this in argmin library                              *)
(* -------------------------------------------------------------------------- *)
val FOLDR_DOMAIN = cj 1 FOLDR_DOMAIN_HELPER;

(* -------------------------------------------------------------------------- *)
(* TODO: Remove: obsolete due to addition of argmin library                   *)
(* -------------------------------------------------------------------------- *)
(* -------------------------------------------------------------------------- *)
(* TODO: Write version of this in argmin library                              *)
(* -------------------------------------------------------------------------- *)
Theorem FOLDR_DOMAIN_MEM_HELPER:
  ∀f g l ls.
  (∀x y. MEM x (l::ls) ∧ MEM y (l::ls) ⇒ f x y = g x y ∧ MEM (f x y) (l::ls)) ⇒
  FOLDR f l ls = FOLDR g l ls ∧ MEM (FOLDR f l ls) (l::ls)
Proof
  rpt gen_tac
  >> rpt disch_tac
  >> irule FOLDR_DOMAIN_HELPER
  >> rpt strip_tac >> gvs[]
QED

(* -------------------------------------------------------------------------- *)
(* TODO: Remove: obsolete due to addition of argmin library                   *)
(* -------------------------------------------------------------------------- *)
(* -------------------------------------------------------------------------- *)
(* TODO: Write version of this in argmin library                              *)
(* -------------------------------------------------------------------------- *)
val FOLDR_DOMAIN_MEM = cj 1 FOLDR_DOMAIN_MEM_HELPER;



(* -------------------------------------------------------------------------- *)
(* TODO: obsolete                                                             *)
(* -------------------------------------------------------------------------- *)
Theorem get_better_origin_slow_biswitch[simp]:
  ∀m bs t x y.
  get_better_origin_slow m bs t x y = x ∨
  get_better_origin_slow m bs t x y = y
Proof
  rpt strip_tac
  >> gvs[get_better_origin_slow_def]
  >> qmatch_goalsub_abbrev_tac ‘if b then _ else _’
  >> Cases_on ‘b’ >> gvs[]
QED

(* -------------------------------------------------------------------------- *)
(* TODO: obsolete                                                             *)
(* -------------------------------------------------------------------------- *)
Theorem FOLDR_get_better_origin_slow:
  ∀m bs t r rs.
  MEM (FOLDR (λa' a. get_better_origin_slow m bs t a' a) r rs) (r::rs)
Proof
  rpt strip_tac
  >> gvs[FOLDR_BISWITCH]
QED


(*(* -------------------------------------------------------------------------- *)
(* The result of folding get_better_origin over a list is the list itself,    *)
(* since at each stage, the output is equal to one of the inputs.             *)
(* -------------------------------------------------------------------------- *)
Theorem get_better_origin_foldr_mem:
  ∀m bs t ps h ts.
  MEM (FOLDR (get_better_origin m bs t ps) h ts) (h::ts)
Proof
  rpt strip_tac
  >> irule FOLDR_BISWITCH
  >> rpt strip_tac
  >> gvs[get_better_origin_def]
  >> qmatch_goalsub_abbrev_tac ‘if b then _ else _’
  >> Cases_on ‘b’
  >> gvs[]
QED
 *)


(*
Theorem best_origin_is_valid:
  ∀m bs t ps s.
  wfmachine m ∧
  s < m.num_states ⇒
  (best_origin m bs t ps s).origin < m.num_states
Proof
  rpt strip_tac
  >> gvs[best_origin_def]
  >> qmatch_goalsub_abbrev_tac ‘FOLDR fn _ _’
  >> qmatch_goalsub_abbrev_tac ‘FOLDR _ (HD ts)’
  >> qmatch_goalsub_abbrev_tac ‘tran.origin < _’
  (* Use the proof that transition_inverse always returns a valid state
     to simplify to merely needing to prove that t is a member of ts. *)
  >> qsuff_tac ‘MEM tran ts’
  >- (strip_tac
      >> qspecl_then [‘m’, ‘s’] assume_tac transition_inverse_valid
      >> gvs[Abbr ‘ts’]
      >> gvs[EVERY_MEM])
  (* t can only be a member of ts if ts is nonempty, so prove that ts is nonempty, using the fact that transition_inverse is nonempty given a well formed machine and valid state.*)
  >> sg ‘ts ≠ []’
  >- (gvs[Abbr ‘ts’]
      >> gvs[transition_inverse_nonempty])
  (* No longer need the information provided by the exact form of ts. The fact that it is a nonempty bitstring is enough. *)
  >> delete_nth_assumption 2
  (* Use get_better_origin_foldr_mem to finish the proof. Since the function's
     output is always one of the inputs, folding the function over a list
     will always give you a member of that list. *)
  >> unabbrev_all_tac
  >> Cases_on ‘ts’
  >- gvs[]
  >> MEM_DONOTEXPAND_TAC
  >> simp[get_better_origin_foldr_mem]
  >> MEM_DOEXPAND_TAC
  >> PURE_REWRITE_TAC[get_better_origin_foldr_mem]
QED
*)


(*Theorem get_better_final_state_foldr_mem:
  ∀rs h ts.
  MEM (FOLDR (get_better_final_state rs) h ts) (h::ts)
Proof
  rpt strip_tac
  >> irule FOLDR_BISWITCH
  >> rpt strip_tac
  >> gvs[get_better_final_state_def]
  >> qmatch_goalsub_abbrev_tac ‘if b then _ else _’
  >> Cases_on ‘b’
  >> gvs[]
QED*)



(* ========================================================================== *)
(*                                                                            *)
(*                                                                            *)
(*                                                                            *)
(* ========================================================================== *)

(* -------------------------------------------------------------------------- *)
(* Performs one step back through the trellis.                                *)
(*                                                                            *)
(* m: the state machine which generates the trellis                           *)
(* bs: the bitstring being decoded                                            *)
(* s: the state to step back from                                             *)
(* t: the time-step to step back from                                         *)
(*                                                                            *)
(* Only valid for t > 0, since we can't step back at t = 0.                   *)
(* -------------------------------------------------------------------------- *)
(* Note: this requires generating the entire trellis up to this point, which  *)
(* is slow. Repeatedly calling this function should therefore in theory be    *)
(* less efficient than generating the trellis once and then stepping back     *)(* through the thing.                                                         *)
(* -------------------------------------------------------------------------- *)
Definition vd_step_back_def:
  vd_step_back m bs s t =
  let
    trellis_row = viterbi_trellis_row m bs t;
    trellis_node = EL s trellis_row
  in
    (THE trellis_node.prev_transition).origin
End


(* -------------------------------------------------------------------------- *)
(* vd_find_optimal_path, but converted to code form                           *)
(* -------------------------------------------------------------------------- *)
Definition vd_find_optimal_code_def:
  vd_find_optimal_code m bs s t = path_to_code m (vd_find_optimal_path m bs s t)
End


Theorem vd_find_optimal_path_nonempty[simp]:
  ∀m bs s t.
    vd_find_optimal_path m bs s t ≠ []
Proof
  rpt strip_tac
  >> Cases_on ‘t’ >> gvs[vd_find_optimal_path_def]
QED



Theorem vd_find_optimal_path_time_zero[simp]:
  ∀m bs s t. vd_find_optimal_path m bs s 0 = [s]
Proof
  rpt strip_tac
  >> EVAL_TAC
QED

Theorem vd_find_optimal_path_length[simp]:
  ∀m bs s t.
    LENGTH (vd_find_optimal_path m bs s t) = t + 1
Proof
  gen_tac
  (* Induct over t *)
  >> Induct_on ‘t’
  >- (rpt strip_tac >> EVAL_TAC)
  (* Expand out definitions *)
  >> gvs[vd_find_optimal_path_def, vd_step_back_def]
QED

Theorem vd_find_optimal_path_last[simp]:
  ∀m bs s t.
    LAST (vd_find_optimal_path m bs s t) = s
Proof
  Induct_on ‘t’ >> rpt strip_tac >> gvs[]
  >> gvs[vd_find_optimal_path_def]
  >> gvs[vd_find_optimal_reversed_path_def]
QED

Theorem vd_find_optimal_path_suc:
  ∀m bs s t.
    vd_find_optimal_path m bs s (SUC t) = SNOC s (vd_find_optimal_path m bs (vd_step_back m bs s (SUC t)) t)
Proof
  rpt strip_tac
  >> PURE_REWRITE_TAC[vd_find_optimal_path_def]
  >> PURE_REWRITE_TAC[GSYM (cj 2 REVERSE_SNOC_DEF)]
  >> AP_TERM_TAC
  >> gvs[vd_find_optimal_reversed_path_def]
QED

Theorem vd_find_optimal_reversed_path_length[simp]:
  ∀m bs s t.
    LENGTH (vd_find_optimal_reversed_path m bs s t) = t + 1
Proof
  gvs[vd_find_optimal_reversed_path_def]
QED

(* -------------------------------------------------------------------------- *)
(* This is already contained in the definition of                             *)
(* vd_find_optimal_reversed_path, but it is good to automatically use it      *)
(* -------------------------------------------------------------------------- *)
Theorem vd_find_optimal_reversed_path_time_zero[simp]:
  ∀m bs s.
    vd_find_optimal_reversed_path m bs s 0 = [s]
Proof
  rpt strip_tac >> EVAL_TAC
QED


(*(* -------------------------------------------------------------------------- *)
(* Theorem statement not designed by hand: identified after seeing what       *)
(* happens when we expand out vd_find_optimal_code in order to remove the     *)
(* SUC, intended for use in applying the inductive step.                      *)
(* -------------------------------------------------------------------------- *)
Theorem vd_find_optimal_code_suc:
  ∀m bs s t.
    vd_find_optimal_code m bs s (SUC t) = vd_find_optimal_code m bs (vd_step_back m bs s (SUC t)) t ⧺ [states_to_transition_input m (vd_step_back m bs s (SUC t))s] 
Proof
  gvs[vd_find_optimal_code_def]
  >> gvs[vd_find_optimal_path_def]
  >> gvs[vd_find_optimal_reversed_path_def]
  >> gvs[GSYM vd_find_optimal_reversed_path_def]
  >> gvs[GSYM vd_find_optimal_path_def]
  >> gvs[path_to_code_append]
  >> gvs[GSYM vd_find_optimal_code_def]
QED*)


(* -------------------------------------------------------------------------- *)
(* Alternate definition that could be used for vd_find_optimal_code           *)
(* -------------------------------------------------------------------------- *)
Theorem vd_find_optimal_code_suc':
  ∀m bs s t.
    vd_find_optimal_code m bs s (SUC t) =
    let
      x = vd_step_back m bs s (SUC t)
    in
      vd_find_optimal_code m bs x t ⧺ [states_to_transition_input m x s]
Proof
  gvs[vd_find_optimal_code_def]
  >> gvs[vd_find_optimal_path_def]
  >> gvs[vd_find_optimal_reversed_path_def]
  >> gvs[GSYM vd_find_optimal_reversed_path_def]
  >> gvs[GSYM vd_find_optimal_path_def]
  >> gvs[path_to_code_append]
  >> gvs[GSYM vd_find_optimal_code_def]
QED

(* -------------------------------------------------------------------------- *)
(* Alternate method to prove a theorem without having to re-write out the     *)
(* entire statement of the theorem.                                           *)
(* -------------------------------------------------------------------------- *)
Theorem vd_find_optimal_code_suc'' =
        “vd_find_optimal_code m bs s (SUC t)”
          |> SCONV  [vd_find_optimal_code_def, vd_find_optimal_path_def,
                     vd_find_optimal_reversed_path_def]
          |> SRULE [GSYM vd_find_optimal_reversed_path_def,
                    GSYM vd_find_optimal_path_def,
                    path_to_code_append,
                    GSYM vd_find_optimal_code_def]
          |> GEN_ALL


Theorem vd_step_back_is_valid[simp]:
  ∀m bs s t.
    wfmachine m ∧
    s < m.num_states ∧
    0 < t ∧
    is_reachable m s t ⇒
    vd_step_back m bs s t < m.num_states
Proof
  rpt strip_tac
  >> gvs[vd_step_back_def]
  >> Cases_on ‘t’ >> gvs[]
  >> PURE_REWRITE_TAC[GSYM viterbi_trellis_node_no_prev_data_def]
  >> gvs[GSYM viterbi_trellis_node_slow_viterbi_trellis_node_no_prev_data]
  >> Cases_on ‘(viterbi_trellis_node_slow m bs s (SUC n)).prev_transition’
  >- metis_tac[is_reachable_viterbi_trellis_node_slow_prev_transition]
  >> gvs[]
  >> gvs[viterbi_trellis_node_slow_def]
QED


Theorem vd_step_back_restrict_input:
  ∀m bs s t n.
    t * m.output_length ≤ n ⇒
    vd_step_back m (TAKE n bs) s t = vd_step_back m bs s t
Proof
  rpt strip_tac
  >> gvs[vd_step_back_def]
  >> gvs[viterbi_trellis_row_restrict_input]
QED


Theorem vd_step_back_restrict_input_apply:
  ∀m bs s t.
    vd_step_back m bs s t = vd_step_back m (TAKE (t * m.output_length) bs) s t
Proof
  gvs[vd_step_back_restrict_input]
QED


Theorem vd_find_optimal_code_restrict_input_apply:
  ∀m bs s t.
    vd_find_optimal_code m bs s t = vd_find_optimal_code m (TAKE (t * m.output_length) bs) s t
Proof
  gvs[vd_find_optimal_code_restrict_input]
QED


(* -------------------------------------------------------------------------- *)
(* Alternate definition of the step_back function which uses the slow trellis *)
(* code                                                                       *)
(* -------------------------------------------------------------------------- *)
Theorem vd_step_back_def_slow:
  ∀m bs s t.
    wfmachine m ∧
    s < m.num_states ⇒
    vd_step_back m bs s t = (THE (viterbi_trellis_node_slow m bs s t).prev_transition).origin
Proof
  rpt strip_tac
  >> gvs[vd_step_back_def]
  >> Cases_on ‘t’ >> gvs[]
  >- (gvs[viterbi_trellis_node_slow_def]
      >> EVAL_TAC >> Cases_on ‘s’ >> gvs[])
  >> gvs[viterbi_trellis_node_slow_viterbi_trellis_node_no_prev_data]
QED

Theorem is_reachable_vd_step_back:
  ∀m bs s t.
    wfmachine m ∧
    s < m.num_states ∧
    is_reachable m s (SUC t) ⇒
    is_reachable m (vd_step_back m bs s (SUC t)) t
Proof
  rpt strip_tac
  >> gvs[vd_step_back_def_slow]
  >> gvs[viterbi_trellis_node_slow_def]
  >> gvs[get_num_errors_after_step_slow_is_reachable]
  >> gvs[is_reachable_best_origin_slow]
QED


(* -------------------------------------------------------------------------- *)
(* test_path: [F; T; T; F; T; T; T; T; F; F; T; F]                            *)
(*                                                                            *)
(*   0 -> 0/00 -> 0                                                           *)
(*     -> 1/11 -> 1                                                           *)
(*   1 -> 0/11 -> 2                                                           *)
(*     -> 1/00 -> 3                                                           *)
(*   2 -> 0/10 -> 0                                                           *)
(*     -> 1/01 -> 1                                                           *)
(*   3 -> 0/01 -> 2                                                           *)
(*     -> 1/10 -> 3                                                           *)
(*                                                                            *)
(* 0  1  2  3  3  3  4                -  0  0  2  2  02 0                     *)
(* -  1  2  2  3  3  4                -  0  0  0  02 2  0                     *)
(* -  -  2  2  2  5  4                -  -  1  1  1  13 13                    *)
(* -  -  2  3  4  3  3                -  -  1  3  13 1  3                     *)
(*    FT TF TT TT FF TF                  FT TF TT TT FF TF                    *)
(*                                                                            *)
(* Starting at state 0, t=6: [0, 0, 0, 2, 1, 0, 0]                            *)
(*                               .. 2, 1, 0, 0, 0]                            *)
(*                                                                            *)
(*                                                                            *)
(* Starting at state 1, t=4: [1, 0, 2, 1, 0]                                  *)
(*                            .. 2, 1, 0, 0]                                  *)
(*                                                                            *)
(* Starting at state 2, t=4: [2, 1, 0, 0, 0]                                  *)
(*                                                                            *)
(* Starting at state 3, t=6; [3, 3, 1, 0, 2, 1, 0]                            *)
(*                                  .. 2, 1, 0, 0]                            *)
(* -------------------------------------------------------------------------- *)
Theorem vd_find_optimal_reversed_path_test:
  let
    result1 = (vd_find_optimal_reversed_path example_state_machine test_path 0 6);
    result2 = (vd_find_optimal_reversed_path example_state_machine test_path 1 4);
    result3 = (vd_find_optimal_reversed_path example_state_machine test_path 2 4);
    result4 = (vd_find_optimal_reversed_path example_state_machine test_path 3 6);
  in
    (result1 = [0;0;0;2;1;0;0] ∨ result1 = [0;0;2;1;0;0;0]) ∧
    (result2 = [1;0;2;1;0] ∨ result2 = [1;2;1;0;0]) ∧
    (result3 = [2;1;0;0;0]) ∧
    (result4 = [3;3;1;0;2;1;0] ∨ result4 = [3;3;1;2;1;0;0])
Proof
  EVAL_TAC
QED





(* ========================================================================== *)
(*                                                                            *)
(*                                                                            *)
(*                                                                            *)
(* ========================================================================== *)



(* -------------------------------------------------------------------------- *)
(* Obsolete. We no longer need to work with paths when decoding.              *)
(* TODO: Move to obsolete.txt, along with relevant theorems                   *)
(* -------------------------------------------------------------------------- *)
Definition code_to_path_from_state_def:
  code_to_path_from_state m [] s = [s] ∧
  code_to_path_from_state m (b::bs) s =  s::(code_to_path_from_state m bs (m.transition_fn <| origin := s; input := b; |>).destination)
End

(* -------------------------------------------------------------------------- *)
(* Obsolete. We no longer need to work with paths when decoding               *)
(* TODO: Move to obsolete.txt, along with relevant theorems                   *)
(* -------------------------------------------------------------------------- *)
Definition code_to_path_def:
  code_to_path m bs = code_to_path_from_state m bs 0
End


(* -------------------------------------------------------------------------- *)
(* Takes a state machine and two states, and returns the input that would     *)
(* lead between those states.                                                 *)
(*                                                                            *)
(* Returns either F or T arbitrarily (undefined behaviour) if there is no     *)
(* such input.                                                                *)
(* -------------------------------------------------------------------------- *)
Definition states_to_transition_input_def:
  states_to_transition_input m s1 s2 =
  let
    output_on_F = m.transition_fn <| origin := s1; input := F |>
  in
    if output_on_F.destination = s2 then F else T
End

(* -------------------------------------------------------------------------- *)
(* Takes a sequence of states which denotes a path through the state machine, *)
(* and returns the sequence of 0s/1s which would produce that path through    *)
(* the state machine                                                          *)
(* -------------------------------------------------------------------------- *)
Definition path_to_code_def:
  path_to_code m [] = [] ∧
  path_to_code m (p::[]) = [] ∧
  path_to_code m (p1::p2::ps) = (states_to_transition_input m p1 p2) :: (path_to_code m (p2::ps))
End


(* -------------------------------------------------------------------------- *)
(* This should be automatically expanded, because it's not an important       *)
(* enough definition to write out a bunch of theorems for, but it is          *)
(* complicated enough that I feel it may deserve its own name.                *)
(* -------------------------------------------------------------------------- *)
Definition vd_can_step_def:
  vd_can_step m s s' = ∃b. (m.transition_fn <| origin := s; input := b; |>).destination = s'
End

Definition path_is_connected_def:
  path_is_connected m [] = T ∧
  path_is_connected m (p::[]) = T ∧
  path_is_connected m (p::p'::ps) = (vd_can_step m p p' ∧ path_is_connected m (p'::ps))
End

Definition path_is_valid_def:
  path_is_valid m ps = ∃bs. code_to_path m bs = ps
End

Definition path_is_valid_from_state_def:
  path_is_valid_from_state m ps s = ∃bs. code_to_path_from_state m bs s = ps
End

Definition path_is_valid_or_empty_def:
  path_is_valid_or_empty m ps = ((ps = []) ∨ path_is_valid m ps)
End  


Theorem code_to_path_from_state_hd:
  ∀m bs s.
    HD (code_to_path_from_state m bs s) = s
Proof
  Induct_on ‘bs’
  >- (rpt strip_tac >> EVAL_TAC)
  >> rpt strip_tac
  >> gvs[code_to_path_from_state_def]
QED

Theorem code_to_path_hd:
  ∀m bs.
    HD (code_to_path m bs) = 0
Proof
  gvs[code_to_path_from_state_hd, code_to_path_def]
QED

Theorem code_to_path_from_state_null[simp]:
  ∀m bs s.
    ¬NULL (code_to_path_from_state m bs s)
Proof
  rpt strip_tac
  >> Cases_on ‘bs’
  >> gvs[code_to_path_from_state_def]
QED

Theorem code_to_path_null[simp]:
  ∀m bs.
    ¬NULL (code_to_path m bs)
Proof
  gvs[code_to_path_def, code_to_path_from_state_null]
QED

Theorem code_to_path_from_state_length:
  ∀m bs s.
    LENGTH (code_to_path_from_state m bs s) = LENGTH bs + 1
Proof
  Induct_on ‘bs’ >> rpt strip_tac >> gvs[code_to_path_from_state_def]
QED

Theorem code_to_path_length:
  ∀m bs.
    LENGTH (code_to_path m bs) = LENGTH bs + 1
Proof
  rpt strip_tac
  >> gvs[code_to_path_def, code_to_path_from_state_length] 
QED

Theorem code_to_path_from_state_nonempty[simp]:
  ∀m bs s.
    code_to_path_from_state m bs s ≠ []
Proof
  rpt strip_tac
  >> gvs[GSYM NULL_EQ, code_to_path_from_state_null]
QED

Theorem code_to_path_nonempty[simp]:
  ∀m bs.
    code_to_path m bs ≠ []
Proof
  gvs[code_to_path_from_state_nonempty, code_to_path_def]
QED

Theorem code_to_path_from_state_append:
  ∀m bs cs s.
    code_to_path_from_state m (bs ⧺ cs) s = (code_to_path_from_state m bs s) ⧺ (TL (code_to_path_from_state m cs (vd_encode_state_from_state m bs s)))
Proof
  Induct_on ‘bs’
  >- (EVAL_TAC
      >> rpt strip_tac
      >> qspecl_then [‘m’, ‘cs’, ‘s’] assume_tac code_to_path_from_state_hd
      >> qmatch_goalsub_abbrev_tac ‘TL donotrewrite’
      >> last_x_assum (fn th => PURE_ONCE_REWRITE_TAC[GSYM th])
      >> unabbrev_all_tac
      >> DEP_PURE_ONCE_REWRITE_TAC[CONS]
      >> gvs[])
  >> rpt strip_tac
  >> gvs[]
  >> gvs[code_to_path_from_state_def]
  >> gvs[vd_encode_state_from_state_def]
QED

Theorem code_to_path_from_state_snoc:
  ∀m b bs s.
    code_to_path_from_state m (SNOC b bs) s = SNOC ((m.transition_fn <| origin := (vd_encode_state_from_state m bs s); input := b |>).destination ) (code_to_path_from_state m bs s)
Proof
  rpt strip_tac
  >> gvs[SNOC]
  >> gvs[code_to_path_from_state_append]
  >> gvs[code_to_path_from_state_def]
QED

Theorem code_to_path_append:
  ∀m bs cs.
    code_to_path m (bs ⧺ cs) = (code_to_path m bs) ⧺ (TL (code_to_path_from_state m cs (vd_encode_state m bs)))
Proof
  rpt strip_tac
  >> gvs[code_to_path_def, code_to_path_from_state_append, vd_encode_state_def]
QED

Theorem code_to_path_snoc:
  ∀m b bs.
    code_to_path m (SNOC b bs) = SNOC ((m.transition_fn <| origin := (vd_encode_state m bs); input := b |>).destination) (code_to_path m bs)
Proof
  rpt strip_tac
  >> PURE_REWRITE_TAC[code_to_path_def]
  >> PURE_REWRITE_TAC[code_to_path_from_state_snoc]
  >> gvs[]
  >> gvs[vd_encode_state_def]
QED

Theorem code_to_path_from_state_last:
  ∀m bs s.
    LAST (code_to_path_from_state m bs s) = (vd_encode_state_from_state m bs s)
Proof
  Induct_on ‘bs’ >> rpt strip_tac
  >- EVAL_TAC
  >> gvs[vd_encode_state_from_state_def]
  >> gvs[code_to_path_from_state_def]
  >> pop_assum $ qspecl_then [‘m’, ‘(m.transition_fn <| origin := s; input := h |>).destination’] assume_tac
  >> pop_assum (fn th => gvs[SYM th])
  >> gvs[LAST_DEF]
QED

Theorem code_to_path_last:
  ∀m bs.
    LAST (code_to_path m bs) = (vd_encode_state m bs)
Proof
  gvs[code_to_path_from_state_last, code_to_path_def, vd_encode_state_def]
QED

Theorem code_to_path_from_state_vd_can_step_cons:
  ∀m bs p p' ps s.
    code_to_path_from_state m bs s = p::p'::ps ⇒
    vd_can_step m p p'
Proof
  rpt strip_tac
  >> Cases_on ‘bs’
  >- gvs[code_to_path_def, code_to_path_from_state_def]
  >> gvs[code_to_path_def, code_to_path_from_state_def]
  >> Cases_on ‘t’
  >- (gvs[code_to_path_def, code_to_path_from_state_def]
      >> gvs[vd_can_step_def]
      >> qexists ‘h’
      >> gvs[])
  >> gvs[code_to_path_from_state_def]
  >> gvs[vd_can_step_def]
  >> qexists ‘h’
  >> gvs[]
QED

Theorem code_to_path_from_state_vd_can_step:
  ∀m bs p p' ps ps' s.
    code_to_path_from_state m bs s = (ps ⧺ [p; p'] ⧺ ps') ⇒
    vd_can_step m p p'
Proof
  Induct_on ‘ps’
  >- (rpt strip_tac
      >> gvs[]
      >> irule code_to_path_from_state_vd_can_step_cons
      >> qexistsl [‘bs’, ‘ps'’, ‘s’]
      >> gvs[]
     )
  >> rpt strip_tac
  >> last_x_assum irule
  >> Cases_on ‘bs’
  >- gvs[code_to_path_def, code_to_path_from_state_def]
  >> gvs[]
  >> gvs[code_to_path_def, code_to_path_from_state_def]
  >> qexistsl [‘t’, ‘ps'’, ‘(m.transition_fn <| origin := h; input := h' |>).destination’]
  >> gvs[]
QED

Theorem code_to_path_from_state_vd_can_step_snoc:
  ∀m bs p p' ps s.
    code_to_path_from_state m bs s  = SNOC p' (SNOC p ps) ⇒
    vd_can_step m p p'
Proof
  rpt strip_tac
  >> irule code_to_path_from_state_vd_can_step
  >> qexistsl [‘bs’, ‘ps’, ‘[]’, ‘s’]
  >> gvs[]
QED

Theorem code_to_path_vd_can_step_cons:
  ∀m bs p p' ps.
    code_to_path m bs = p::p'::ps ⇒
    vd_can_step m p p'
Proof
  metis_tac[code_to_path_def, code_to_path_from_state_vd_can_step_cons]
QED

Theorem code_to_path_vd_can_step:
  ∀m bs p p' ps ps'.
    code_to_path m bs = (ps ⧺ [p; p'] ⧺ ps') ⇒
    vd_can_step m p p'
Proof
  metis_tac[code_to_path_def, code_to_path_from_state_vd_can_step]
QED

Theorem code_to_path_vd_can_step_snoc:
  ∀m bs p p' ps.
    code_to_path m bs = SNOC p' (SNOC p ps) ⇒
    vd_can_step m p p'
Proof
  metis_tac[code_to_path_def, code_to_path_from_state_vd_can_step_snoc]
QED


(* -------------------------------------------------------------------------- *)
(* If there exists a way to step from s to s', then states_to_transition_input*)
(* will return that way.                                                      *)
(* -------------------------------------------------------------------------- *)
Theorem transition_fn_states_to_transition_input:
  ∀m s s' b. (m.transition_fn <| origin := s; input := b |>).destination = s' ⇒
             (m.transition_fn <| origin := s; input := (states_to_transition_input m s s') |>).destination = s'
Proof
  rpt strip_tac
  >> simp[states_to_transition_input_def]
  >> Cases_on ‘(m.transition_fn <|origin := s; input := F|>).destination ≠ s'’ >> simp[]
  >> Cases_on ‘b’ >> gvs[]
QED

Theorem states_to_transition_input_transition_fn:
  ∀m b s.
    wfmachine m ∧
    s < m.num_states ⇒
    states_to_transition_input m s (m.transition_fn <| origin := s; input := b |>).destination = b
Proof
  rpt strip_tac
  >> Cases_on ‘b’ >> EVAL_TAC
  >> drule wfmachine_transition_fn_from_state_injective
  >> rpt strip_tac
  >> gvs[]
QED

Theorem states_to_transition_input_vd_encode_state_snoc:
  ∀m b bs.
    wfmachine m ⇒
    states_to_transition_input m (vd_encode_state m bs) (vd_encode_state m (SNOC b bs)) = b
Proof
  rpt strip_tac
  >> gvs[vd_encode_state_snoc]
  >> gvs[states_to_transition_input_transition_fn]
QED

Theorem path_to_code_singleton[simp]:
  ∀m s. path_to_code m [s] = []
Proof
  rpt strip_tac
  >> EVAL_TAC
QED

Theorem path_to_code_length[simp]:
  ∀m ps.
    LENGTH (path_to_code m ps) = LENGTH ps - 1
Proof
  rpt strip_tac
  >> Induct_on ‘ps’
  >- EVAL_TAC
  >> rpt strip_tac
  >> Cases_on ‘ps’
  >- EVAL_TAC
  >> gvs[path_to_code_def]
QED

Theorem path_to_code_append:
  ∀m ss ss'.
    ss ≠ [] ∧ ss' ≠ [] ⇒
    path_to_code m (ss ⧺ ss') = path_to_code m ss ⧺ (states_to_transition_input m (LAST ss) (HD ss')) :: (path_to_code m ss')
Proof
  gen_tac
  >> Induct_on ‘ss’ >> rpt strip_tac
  >- gvs[]
  >> Cases_on ‘ss’
  >- (gvs[]
      >> Cases_on ‘ss'’
      >- gvs[]
      >> gvs[path_to_code_def])
  >> gvs[path_to_code_def]
QED

Theorem path_to_code_snoc:
  ∀m s ss.
    ss ≠ [] ⇒
    path_to_code m (SNOC s ss) = SNOC (states_to_transition_input m (LAST ss) s) (path_to_code m ss)
Proof
  rpt strip_tac
  >> gvs[path_to_code_append]
QED

Theorem path_to_code_code_to_path:
  ∀m bs.
    wfmachine m ⇒
    path_to_code m (code_to_path m bs) = bs
Proof
  rpt strip_tac
  >> Induct_on ‘bs’ using SNOC_INDUCT
  >- EVAL_TAC
  >> rpt strip_tac
  >> gvs[]
  >> gvs[code_to_path_append]
  >> DEP_PURE_ONCE_REWRITE_TAC[path_to_code_append]
  >> gvs[]
  >> conj_tac
  >- (gvs[code_to_path_from_state_def])
  >> REVERSE conj_tac
  >- (gvs[code_to_path_from_state_def])
  >> gvs[code_to_path_def, vd_encode_state_def]
  >> gvs[code_to_path_from_state_def]
  >> gvs[code_to_path_from_state_last]
  >> DEP_PURE_ONCE_REWRITE_TAC[states_to_transition_input_transition_fn]
  >> gvs[]
  >> irule vd_encode_state_from_state_is_valid
  >> gvs[]
QED


Theorem vd_can_step_vd_step[simp]:
  ∀m b s.
    vd_can_step m s (m.transition_fn <| origin := s; input := b |>).destination
Proof
  rpt strip_tac
  >> gvs[vd_can_step_def]
  >> qexists ‘b’
  >> gvs[]
QED

Theorem path_is_connected_cons1:
  ∀m h t.
    path_is_connected m (h::t) ⇒
    path_is_connected m t
Proof
  rpt strip_tac
  >> Induct_on ‘t’ >> gvs[path_is_connected_def]
QED

Theorem path_is_connected_append1:
  ∀m p1 p2.
    path_is_connected m (p1 ⧺ p2) ⇒ path_is_connected m p1 ∧ path_is_connected m p2
Proof
  rpt strip_tac
  >- (Induct_on ‘p1’
      >- gvs[path_is_connected_def]
      >> rpt strip_tac
      >> Cases_on ‘p1’
      >- gvs[path_is_connected_def]
      >> gvs[path_is_connected_def])
  >> Induct_on ‘p1’
  >- gvs[]
  >> rpt strip_tac
  >> Cases_on ‘p1’ >> gvs[path_is_connected_def]
  >> Cases_on ‘p2’ >> gvs[path_is_connected_def]
QED

Theorem path_is_connected_snoc1:
  ∀m p ps.
    path_is_connected m (SNOC p ps) ⇒ path_is_connected m ps
Proof
  rpt strip_tac
  >> Induct_on ‘ps’
  >- gvs[path_is_connected_def]
  >> rpt strip_tac
  >> Cases_on ‘ps’ >> gvs[path_is_connected_def]
QED

(* -------------------------------------------------------------------------- *)
(* This proof contains a significant amount of repetition. Perhaps it could   *)
(* be automated?                                                              *)
(*                                                                            *)
(* TODO: What is path_is_connected_append1? Repetition?                       *)
(* -------------------------------------------------------------------------- *)
Theorem path_is_connected_append:
  ∀m p p' ps ps'.
    path_is_connected m (ps ⧺ [p; p'] ⧺ ps') ⇔
      path_is_connected m ps ∧
      path_is_connected m ps' ∧
      vd_can_step m p p' ∧
      (ps = [] ∨ vd_can_step m (LAST ps) p) ∧
      (ps' = [] ∨ vd_can_step m p' (HD ps'))
Proof
  rpt strip_tac
  >> Induct_on ‘ps’ >> gvs[path_is_connected_def]
  >- (gvs[]
      >> Induct_on ‘ps'’ >> gvs[path_is_connected_def]
      >> rpt strip_tac
      >> Cases_on ‘ps'’ >> gvs[path_is_connected_def]
      >> decide_tac)
  >> rpt strip_tac
  >> Cases_on ‘ps’
  >- (gvs[path_is_connected_def]
      >> Induct_on ‘ps'’ >> gvs[path_is_connected_def]
      >- decide_tac
      >> rpt strip_tac
      >> decide_tac
     )   
  >> Cases_on ‘ps'’ >> gvs[path_is_connected_def]
  >- (gvs[path_is_connected_def]
      >> decide_tac)
  >> gvs[path_is_connected_def]
  >> decide_tac
QED

Theorem path_is_connected_snoc:
  ∀m p p' ps.
    path_is_connected m (SNOC p' (SNOC p ps)) ⇔ vd_can_step m p p' ∧ path_is_connected m (SNOC p ps)
Proof
  rpt strip_tac
  >> EQ_TAC
  >- (rpt strip_tac
      >- (gvs[]
          >> Induct_on ‘ps’
          >- (gvs[]
              >> gvs[path_is_connected_def])
          >> rpt strip_tac
          >> Cases_on ‘ps’ >> gvs[path_is_connected_def])
      >> irule path_is_connected_snoc1
      >> qexists ‘p'’
      >> gvs[])
  >> rpt strip_tac
  >> Induct_on ‘ps’
  >- gvs[path_is_connected_def]
  >> rpt strip_tac
  >> Cases_on ‘ps’ >> gvs[path_is_connected_def]
QED

Theorem path_is_connected_cons:
  ∀m p p' ps.
    path_is_connected m (p::p'::ps) ⇔ vd_can_step m p p' ∧ path_is_connected m (p'::ps)
Proof
  rpt strip_tac
  >> qspecl_then [‘m’, ‘p’, ‘p'’, ‘[]’, ‘ps’] assume_tac path_is_connected_append
  >> gvs[path_is_connected_def, vd_can_step_def]
QED

Theorem path_is_connected_code_to_path_from_state:
  ∀m bs s.
    path_is_connected m (code_to_path_from_state m bs s)
Proof
  Induct_on ‘bs’
  >- (rpt strip_tac >> EVAL_TAC)
  >> rpt strip_tac
  >> gvs[code_to_path_from_state_def]
  >> gvs[path_is_connected_cons1]
  >> pop_assum $ qspecl_then [‘m’, ‘(m.transition_fn <| origin := s; input := h |>).destination’] assume_tac
  >> qmatch_goalsub_abbrev_tac ‘(_::ps)’
  >> Cases_on ‘ps’
  >- gvs[]
  >> gvs[path_is_connected_cons]
  >> Cases_on ‘bs’ >> gvs[code_to_path_from_state_def]
QED

Theorem path_is_connected_code_to_path:
  ∀m bs s.
    path_is_connected m (code_to_path m bs)
Proof
  gvs[path_is_connected_code_to_path_from_state, code_to_path_def]
QED

Theorem path_is_valid_nonempty:
  ∀m ps.
    path_is_valid m ps ⇒ ps ≠ []
Proof
  rpt strip_tac
  >> gvs[path_is_valid_def]
QED

Theorem not_path_is_valid_empty[simp]:
  ∀m ps.
    ¬path_is_valid m []
Proof
  gvs[path_is_valid_def]
QED

Theorem path_is_valid_from_state_path_is_connected:
  ∀m ps s.
    path_is_valid_from_state m ps s ⇔ path_is_connected m ps ∧ ps ≠ [] ∧ HD ps = s
Proof
  rpt strip_tac
  >> EQ_TAC
  >- (rpt strip_tac 
      >- (gvs[path_is_valid_from_state_def]
          >> gvs[path_is_connected_code_to_path_from_state])
      >- gvs[path_is_valid_from_state_def]
      >> gvs[path_is_valid_from_state_def]
      >> Cases_on ‘bs’ >> gvs[code_to_path_from_state_def])
  >> rpt strip_tac
  >> gvs[path_is_valid_from_state_def]
  >> Induct_on ‘ps’ using SNOC_INDUCT
  >- gvs[]
  >> rpt strip_tac
  >> Cases_on ‘ps’ using SNOC_CASES >> gvs[code_to_path_def, path_is_connected_def, path_is_valid_from_state_def]
  >- (qexists ‘[]’ >> gvs[code_to_path_from_state_def])
  >> gvs[path_is_connected_snoc]
  >> gs[vd_can_step_def]
  >> qexists ‘SNOC b bs’
  >> Cases_on ‘l’
  >- (gvs[path_is_connected_def]
      >> Cases_on ‘bs’
      >> gvs[code_to_path_from_state_def])
  >> gvs[]
  >> PURE_REWRITE_TAC[GSYM SNOC_APPEND]
  >> PURE_REWRITE_TAC[code_to_path_from_state_snoc]
  >> gvs[]
  >> AP_TERM_TAC
  >> qspecl_then [‘m’, ‘bs’, ‘h’] assume_tac code_to_path_from_state_last
  >> gvs[]
  >> pop_assum (fn th => PURE_REWRITE_TAC [GSYM th])
  >> gvs[LAST_DEF]
QED

Theorem path_is_valid_path_is_valid_from_state:
  ∀m ps.
    path_is_valid m ps ⇔ path_is_valid_from_state m ps 0
Proof
  rpt strip_tac
  >> gvs[path_is_valid_def, path_is_valid_from_state_def, code_to_path_def]
QED

Theorem path_is_valid_path_is_connected:
  ∀m ps.
    path_is_valid m ps ⇔ path_is_connected m ps ∧ ps ≠ [] ∧ HD ps = 0
Proof
  gvs[path_is_valid_path_is_valid_from_state, path_is_valid_from_state_path_is_connected]
QED

Theorem path_is_valid_snoc:
  ∀m p ps.
    path_is_valid m (SNOC p ps) ⇔ (SNOC p ps = [0]) ∨ (vd_can_step m (LAST ps) p ∧ path_is_valid m ps)
Proof
  rpt strip_tac
  >> gvs[path_is_valid_path_is_connected]
  >> Cases_on ‘ps’ >> gvs[]
  >- (Cases_on ‘p’ >> gvs[] >> EVAL_TAC)
  >> Cases_on ‘h = 0’ >> gvs[]
  >> Induct_on ‘t’ using SNOC_INDUCT >> gvs[]
  >- EVAL_TAC
  >> rpt strip_tac
  >> PURE_REWRITE_TAC[GSYM SNOC_CONS]
  >> gvs[path_is_connected_snoc]
QED

Theorem path_is_valid_cons:
  ∀m p ps.
    path_is_valid m (p::ps) ⇔ (p::ps = [0] ∨ (p = 0 ∧ vd_can_step m p (HD ps) ∧ path_is_connected m ps))
Proof
  rpt strip_tac
  >> gvs[path_is_valid_path_is_connected]
  >> Cases_on ‘ps’ >> gvs[]
  >- (Cases_on ‘p’ >> gvs[] >> EVAL_TAC)
  >> Cases_on ‘p = 0’ >> gvs[]
  >> Induct_on ‘t’ >> gvs[]
  >- EVAL_TAC
  >> rpt strip_tac
  >> gvs[path_is_connected_cons]
QED

Theorem path_is_valid_first_two_elements:
  ∀m h h' t.
    path_is_valid m (h::h'::t) ⇒ vd_can_step m h h'
Proof
  rpt strip_tac
  >> gvs[vd_can_step_def]
  >> gvs[path_is_valid_def]
  >> gvs[code_to_path_def]
  >> Cases_on ‘bs’
  >- gvs[code_to_path_from_state_def]
  >> gvs[code_to_path_from_state_def]
  >> Cases_on ‘t'’
  >- (gvs[code_to_path_from_state_def]
      >> qexists ‘h''’ >> gvs[])
  >> gvs[code_to_path_from_state_def]
  >> qexists ‘h''’ >> gvs[]
QED

Theorem path_is_valid_code_to_path:
  ∀m bs.
    path_is_valid m (code_to_path m bs)
Proof
  rpt strip_tac
  >> gvs[path_is_valid_path_is_connected]
  >> gvs[path_is_connected_code_to_path]
  >> Cases_on ‘bs’ >> EVAL_TAC
QED

Theorem path_is_valid_or_empty_code_to_path:
  ∀m bs.
    path_is_valid_or_empty m (code_to_path m bs)
Proof
  gvs[path_is_valid_or_empty_def, path_is_valid_code_to_path]
QED

Theorem code_to_path_from_state_path_to_code:
  ∀m ps.
    ps ≠ [] ∧
    path_is_connected m ps ⇒
    code_to_path_from_state m (path_to_code m ps) (HD ps) = ps
Proof
  rpt strip_tac
  >> Induct_on ‘ps’
  >- gvs[path_is_connected_def]
  >> rpt strip_tac
  >> Cases_on ‘ps’ >> gvs[]
  >- gvs[code_to_path_def, code_to_path_from_state_def]
  >> drule path_is_connected_cons1
  >> rpt strip_tac
  >> gvs[]        
  >> gvs[path_to_code_def]
  >> gvs[code_to_path_from_state_def]
  >> DEP_PURE_ONCE_REWRITE_TAC[transition_fn_states_to_transition_input]
  >> gvs[]
  >> gvs[path_is_connected_def, vd_can_step_def]
  >> qexists ‘b’
  >> gvs[]
QED

Theorem code_to_path_path_to_code:
  ∀m ps.
    ps ≠ [] ∧
    HD ps = 0 ∧
    path_is_connected m ps ⇒
    code_to_path m (path_to_code m ps) = ps
Proof
  metis_tac[code_to_path_def, code_to_path_from_state_path_to_code]
QED

Theorem vd_encode_state_from_state_path_to_code:
  ∀m ps s.
    ps ≠ [] ∧
    HD ps = s ∧
    path_is_connected m ps ⇒
    vd_encode_state_from_state m (path_to_code m ps) s = LAST ps
Proof
  rpt strip_tac
  >> qspecl_then [‘m’, ‘ps’] assume_tac code_to_path_from_state_path_to_code
  >> Cases_on ‘ps’ >> gvs[]
  >> gvs[GSYM code_to_path_from_state_last]
  >> gvs[path_is_valid_path_is_connected]
QED

Theorem vd_encode_state_path_to_code:
  ∀m ps.
    ps ≠ [] ∧
    path_is_valid m ps ⇒
    vd_encode_state m (path_to_code m ps) = LAST ps
Proof
  rpt strip_tac 
  >> gvs[vd_encode_state_def]
  >> DEP_PURE_ONCE_REWRITE_TAC[vd_encode_state_from_state_path_to_code]
  >> gvs[]
  >> gvs[path_is_valid_path_is_connected]
QED
