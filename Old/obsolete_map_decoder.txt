 (*
  >> Induct_on ‘ds’ using SNOC_INDUCT >> Cases_on ‘cs’ using SNOC_CASES >> simp[]
  >> rpt strip_tac
  (* Better names *)
  >> rename1 ‘bxor (SNOC c cs) (SNOC d ds)’
  (* The relevant inductive hypothesis uses cs instead of SNOC c cs, uses
     ds instead of SNOC d ds, and everything else is the same *)
  >> last_x_assum (qspecl_then [‘enc’, ‘n’, ‘m’, ‘p’, ‘cs’] assume_tac)
  >> gs[]
   (* For every choice of bs that produces the sent string cs, any choice of   *)
  (* ns will work to produce that sent string.                                *)
  (*                                                                          *)
  (* If the received string starts with ds and the sent string starts with    *)
  (* cs, then there will be one choice of noise which                         *)
  (*                                                                          *)
  (*                                                                          *)
  (*                                                                          *)
  (*                                                                          *)
  (*                                                                          *) 
  (* ------------------------------------------------------------------------ *)
  (* Let E_cs represent the event of strings starting with cs.                *)
  (*                                                                          *)
  (*                                                                          *)
  (* The event of strings starting with cs is equal to the intersection of    *)
  (* the event of strings starting with SNOC c cs with the event of strings   *)
  (* starting with SNOC (¬c) cs. These are disjoint, thus the conditional     *)
  (* probability is the sum of these two events. Furthermore, the event of    *)
  (* strings starting with SNOC (¬c cs) is equal to MAP-ing a function which  *)
  (* negates the first element over the event of strings starting with        *)
  (* SNOC c cs.                                                               *)
  (*                                                                          *)
  (* Let probC denote the probability of the event of stirngs starting with   *)
  (*                                                                          *)
  (* ------------------------------------------------------------------------ *)
  (* Every string starting with h is formed by prepending h to its              *)
  (* -------------------------------------------------------------------------- *)
  >> gvs[event_received_string_starts_with_def]
  >> gvs[event_sent_string_starts_with_def]
     *)
  >> cheat



  (* COMMENT FOR cond_prob_string_given_sent_prod: *)
  (* We want to prove:                                                        *)
  (* cond_prob (received (SNOC d ds)) (sent (SNOC c cs))                      *)
  (*  = cond_prob (received d) (sent c) * cond_prob (received ds) (sent cs)   *)
  (*                                                                          *)
  (* Then we could simply use our inductive hypthesis on the strings of one   *)
  (* less length, and we could easily calculate the inductive step to be      *)
  (* appropriate.                                                             *)
  (*                                                                          *)
  (* This is intuitively obvious because the value of a given bit is only     *)
  (* affected by the relevant bit that was sent, not by any other bits that   *)
  (* were sent or received.                                                   *)
  (*                                                                          *)
  (* cond_prob (received (SNOC d ds)) (sent (SNOC c cs))                      *)
  (*  = prob (received (SNOC d ds) and sent (SNOC c cs))                      *)
  (*    / prob (sent (SNOC c cs))                                             *)
  (*  = prob (received d and received ds and sent c and sent cs) / ...        *)
  (*  = prob (received d and sent c and received ds and sent cs) / ...        *)
  (*  = prob (received d and sent c) * prob (received ds and sent cs)         *)
  (*    / (prob (sent c) * prob (sent cs))                                    *)
  (*  = cond_prob (received d and sent c) (sent c)                            *)
  (*    cond_prob (received ds and sent cs) (sent cs)                         *)
  (*                                                                          *)
  (* The tricky part in this proof sketch is proving that                     *)
  (* (received d and sent c) is independent of (received ds and sent cs), and *)
  (* that (sent c) is independent of (sent cs)                                *)
  (*                                                                          *)
  (* In fact, at least the second of these properties is false, so this proof *)
  (* sketch won't work.                                                       *) 
