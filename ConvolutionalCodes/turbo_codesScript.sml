open HolKernel Parse boolLib bossLib;

open recursive_parity_equationsTheory;
open interleaveTheory;

val _ = new_theory "turbo_codes";

(* -------------------------------------------------------------------------- *)
(* This is largely based on "Modern Coding Theory" by Tom Richardson and      *)
(* Rüdiger Urbanke.                                                           *)
(* -------------------------------------------------------------------------- *)

(* -------------------------------------------------------------------------- *)
(* An implementation of parallel turbo codes                                  *)
(* -------------------------------------------------------------------------- *)

(* -------------------------------------------------------------------------- *)
(* TODO: Encode the recursive parity equation in a way which is sensible, in  *)
(* particular with regards to the ininitialization and termination schemes    *)
(* -------------------------------------------------------------------------- *)

(* -------------------------------------------------------------------------- *)
(* Encodes a parallel turbo code.                                             *)
(*                                                                            *)
(* This includes the systematic bits, output bits generated by running a      *)
(* recursive convolutional code on the unpermuted input, and output bits      *)
(* generated by running a second recursive convolutional code on the permuted *)
(* input.                                                                     *)
(*                                                                            *)
(* (ps1, qs1): The first set of numerator and denominator parity equations to *)
(*             convolve, represented as bool lists, where the rightmost       *)
(*             element corresponds to the most recently read input.           *)
(* (ps2, qs2): The second set of partity equations to convolve, this time on  *)
(*             the permuted input.                                            *)
(* perm: the permutation to use before applying the second set of parity      *)
(*       equations                                                            *)
(* bs: the input bitstring                                                    *)
(*                                                                            *)
(* Output: a bitstring representing the interleaved systematic bits, output   *)
(*         bits of the first code, and output bits of the second code.        *)
(* -------------------------------------------------------------------------- *)
Definition encode_parallel_turbo_code_def:
  encode_parallel_turbo_code (ps1, qs1) (ps2, qs2) perm bs =
  let
    state_length_1 = MAX (LENGTH ps1) (LENGTH qs1);
    initial_state_1 = REPLICATE state_length_1 F;
    state_length_2 = MAX (LENGTH ps2) (LENGTH qs2);
    initial_state_2 = REPLICATE state_length_2 F;
  in
    interleave
    [bs;
     encode_recursive_parity_equation (ps1, qs1) initial_state_1 bs;
     encode_recursive_parity_equation (ps2, qs2) initial_state_2 (perm bs)
    ]
End


(* -------------------------------------------------------------------------- *)
(* TODO: Is this at all helpful in defining the above or completely unhelpful?*)
(* -------------------------------------------------------------------------- *)
(*Definition parallel_convolutional_code_encode_def:
  parallel_convolutional_code_encode
  (ps1, qs1) (ps2, qs2) bs =
  (bs,
   convolve_recursive_parity_equation code1 bs,
   convolve_recursive_parity equation code2 bs)
End
 *)

(* TODO: define this*)
Definition decode_parallel_turbo_code_def:
  decode_parallel_turbo_code rs bs = ARB
End

(* -------------------------------------------------------------------------- *)
(* Encoding and decoding a recursive parity equation using the BCJR algorithm *)
(* will return the original data again                                        *)
(*                                                                            *)
(* TODO: complete this                                                        *)
(* -------------------------------------------------------------------------- *)
(*Theorem encode_decode_parallel_turbo_code:
  (encode_parallel_turbo_code rs) ∘
  (decode_parallel_turbo_code rs) = I
Proof
QED*)

(* -------------------------------------------------------------------------- *)
(* Ensure that the decoding procedure for a recursive parity equation encoder *)
(* implements an a posteriori encoder (TODO: check that I have my terminology *)
(* correct)                                                                   *)
(*                                                                            *)
(* TODO: complete this                                                        *)
(* -------------------------------------------------------------------------- *)
(*Theorem decode_parallel_turbo_code_a_posteriori:
  (decode_parallel_turbo_code rs)
Proof
QED*)


val _ = export_theory();
