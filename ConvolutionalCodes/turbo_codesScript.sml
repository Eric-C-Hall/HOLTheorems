open HolKernel Parse boolLib bossLib;

open recursive_parity_equationsTheory;
open interleaveTheory;

val _ = new_theory "turbo_codes";

(* -------------------------------------------------------------------------- *)
(* This is largely based on "Modern Coding Theory" by Tom Richardson and      *)
(* Rüdiger Urbanke.                                                           *)
(* -------------------------------------------------------------------------- *)

(* -------------------------------------------------------------------------- *)
(* An implementation of parallel turbo codes                                  *)
(* -------------------------------------------------------------------------- *)

(* -------------------------------------------------------------------------- *)
(* Encodes a parallel turbo code.                                             *)
(*                                                                            *)
(* This includes the systematic bits, output bits generated by running a      *)
(* recursive convolutional code on the unpermuted input, and output bits      *)
(* generated by running a second recursive convolutional code on the permuted *)
(* input.                                                                     *)
(*                                                                            *)
(* (ps, qs): The set of numerator and denominator parity equations to         *)
(*           convolve, represented as bool lists, where the rightmost element *)
(*           corresponds to the most recently read input.                     *)
(* perm: the permutation to use before applying the second set of parity      *)
(*       equations                                                            *)
(* bs: the input bitstring                                                    *)
(*                                                                            *)
(* Output: a bitstring representing the interleaved systematic bits, output   *)
(*         bits of the first code, and output bits of the second code.        *)
(*                                                                            *)
(* Uses zero-tailed encoding. When we reach the end of the string, feedback   *)
(* is disabled, and sufficiently many zeroes are subsequently provided as     *)
(* input to each of the component parity equations to ensure that they end in *)
(* the zero-state. These zeroes are also appended to the input.               *)
(* -------------------------------------------------------------------------- *)
Definition encode_parallel_turbo_code_def:
  encode_parallel_turbo_code (ps, qs) perm bs =
  let
    state_length = MAX (LENGTH ps) (LENGTH qs) - 1;
    initial_state = REPLICATE state_length F;
  in
    interleave
    [bs ++ REPLICATE state_length F;
     encode_recursive_parity_equation_zero_tailed
     (ps, qs) initial_state bs;
     encode_recursive_parity_equation_zero_tailed
     (ps, qs) initial_state (perm bs)
    ]
End


(* -------------------------------------------------------------------------- *)
(* TODO: Is this at all helpful in defining the above or completely unhelpful?*)
(* -------------------------------------------------------------------------- *)
(*Definition parallel_convolutional_code_encode_def:
  parallel_convolutional_code_encode
  (ps1, qs1) (ps2, qs2) bs =
  (bs,
   convolve_recursive_parity_equation code1 bs,
   convolve_recursive_parity equation code2 bs)
End
 *)

(* TODO: define this*)
Definition decode_parallel_turbo_code_def:
  decode_parallel_turbo_code rs bs = ARB
End

(* -------------------------------------------------------------------------- *)
(* Encoding and decoding a recursive parity equation using the BCJR algorithm *)
(* will return the original data again                                        *)
(*                                                                            *)
(* TODO: complete this                                                        *)
(* -------------------------------------------------------------------------- *)
(*Theorem encode_decode_parallel_turbo_code:
  (encode_parallel_turbo_code rs) ∘
  (decode_parallel_turbo_code rs) = I
Proof
QED*)

(* -------------------------------------------------------------------------- *)
(* Ensure that the decoding procedure for a recursive parity equation encoder *)
(* implements an a posteriori encoder (TODO: check that I have my terminology *)
(* correct)                                                                   *)
(*                                                                            *)
(* TODO: complete this                                                        *)
(* -------------------------------------------------------------------------- *)
(*Theorem decode_parallel_turbo_code_a_posteriori:
  (decode_parallel_turbo_code rs)
Proof
QED*)


val _ = export_theory();
