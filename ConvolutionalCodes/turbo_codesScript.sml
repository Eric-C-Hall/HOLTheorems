open HolKernel Parse boolLib bossLib;

open recursive_parity_equationsTheory;
open interleaveTheory;

val _ = new_theory "turbo_codes";

(* -------------------------------------------------------------------------- *)
(* This is largely based on "Modern Coding Theory" by Tom Richardson and      *)
(* Rüdiger Urbanke.                                                           *)
(* -------------------------------------------------------------------------- *)

(* -------------------------------------------------------------------------- *)
(* An implementation of parallel turbo codes                                  *)
(* -------------------------------------------------------------------------- *)

(* -------------------------------------------------------------------------- *)
(* Encodes a parallel turbo code.                                             *)
(*                                                                            *)
(* This includes the systematic bits, output bits generated by running a      *)
(* recursive convolutional code on the unpermuted input, and output bits      *)
(* generated by running a second recursive convolutional code on the permuted *)
(* input.                                                                     *)
(*                                                                            *)
(* (ps, qs): The set of numerator and denominator parity equations to         *)
(*           convolve, represented as bool lists, where the rightmost element *)
(*           corresponds to the most recently read input.                     *)
(* perm: the permutation to use before applying the second set of parity      *)
(*       equations                                                            *)
(* bs: the input bitstring                                                    *)
(*                                                                            *)
(* Output: a bitstring representing the interleaved systematic bits, output   *)
(*         bits of the first code, and output bits of the second code.        *)
(*                                                                            *)
(* Uses zero-tailed encoding. When we reach the end of the string, feedback   *)
(* is disabled, and sufficiently many zeroes are subsequently provided as     *)
(* input to each of the component parity equations to ensure that they end in *)
(* the zero-state. These zeroes are also appended to the input.               *)
(* -------------------------------------------------------------------------- *)
Definition encode_parallel_turbo_code_def:
  encode_parallel_turbo_code (ps, qs) perm bs =
  let
    state_length = MAX (LENGTH ps) (LENGTH qs) - 1;
    initial_state = REPLICATE state_length F;
  in
    interleave
    [bs ++ REPLICATE state_length F;
     encode_recursive_parity_equation_zero_tailed
     (ps, qs) initial_state bs;
     encode_recursive_parity_equation_zero_tailed
     (ps, qs) initial_state (perm bs)
    ]
End

(* -------------------------------------------------------------------------- *)
(* This is largely based on Fundamentals of Convolutional Coding by           *)
(* Rolf Johannesson and Kamil Sh. Zigangirov                                  *)
(* -------------------------------------------------------------------------- *)

(* -------------------------------------------------------------------------- *)
(* Calculates the a posteriori probabilities through the turbo process.       *)
(*                                                                            *)
(* Stops after i turbo iterations.                                            *)
(*                                                                            *)
(* (ps, qs): The numerator and denominator parity equations                   *)
(* perm: The permutation used as part of the encoding process                 *)
(* p: the probability of error in the binary symmetric channel                *)
(* priors: The a priori probabilities that a given input is 1.                *)
(* rs: The received bitstring                                                 *)
(* i: The number of iterations to perform                                     *)
(*                                                                            *)
(* Output: the a posteriori probabilities that a given input is 1.            *)
(* -------------------------------------------------------------------------- *)
(* TODO: is the intrinsic information defined correctly?                      *)
(*                                                                            *)
(*                                                                            *)
(* -------------------------------------------------------------------------- *)
Definition parallel_turbo_code_a_posteriori_def:
  parallel_turbo_code_a_posteriori (ps, qs) perm p priors rs 0 = qs ∧
  parallel_turbo_code_a_posteriori (ps, qs) perm p priors rs (SUC i) =
  let
    rs_s = EL 0 (deinterleave 3 rs);
    rs_1 = EL 1 (deinterleave 3 rs);
    rs_2 = EL 2 (deinterleave 3 rs);
    intermediate_probs = decode_parallel_turbo_code
                         (ps, qs) perm p priors rs i;
    intrinsic_information = MAP (log_likelihood) priors;
    decode_1_probs = 
    ;
    decode_2_probs = ;
                     
  in
    decode 
End

(* -------------------------------------------------------------------------- *)
(* Decodes a parallel turbo code                                              *)
(*                                                                            *)
(* Stops after i turbo iterations.                                            *)
(*                                                                            *)
(* In one turbo iteration, we apply the BCJR algorithm to the first turbo     *)
(* to update the a posteriori probabilities, and then apply it to the second  *)
(* turbo code to update the a posteriori probabilities again.                 *)
(*                                                                            *)
(* (ps, qs): The numerator and denominator parity equations                   *)
(* perm: The permutation used as part of the encoding process                 *)
(* p: the probability of error in the binary symmetric channel                *)
(* priors: The a priori probabilities that a given input is 1.                *)
(* rs: The received bitstring                                                 *)
(* i: The number of iterations to perform                                     *)
(*                                                                            *)
(* Output: the decoded bitstring                                              *)
(* -------------------------------------------------------------------------- *)
Definition decode_parallel_turbo_code_def:
  decode_parallel_turbo_code (ps, qs) perm p priors rs i =
  let
    a_posteriori_probs = parallel_turbo_code_a_posteriori
                         (ps, qs) perm p priors rs i;
  in
    MAP (λx. if 0.5 ≤ x then T else F) a_posteriori_probs
End

(* -------------------------------------------------------------------------- *)
(* Encoding and decoding a recursive parity equation using the BCJR algorithm *)
(* will return the original data again                                        *)
(*                                                                            *)
(* TODO: complete this                                                        *)
(* -------------------------------------------------------------------------- *)
(*Theorem encode_decode_parallel_turbo_code:
  (encode_parallel_turbo_code rs) ∘
  (decode_parallel_turbo_code rs) = I
Proof
QED*)

(* -------------------------------------------------------------------------- *)
(* Ensure that the decoding procedure for a recursive parity equation encoder *)
(* implements an a posteriori encoder (TODO: check that I have my terminology *)
(* correct)                                                                   *)
(*                                                                            *)
(* TODO: complete this                                                        *)
(* -------------------------------------------------------------------------- *)
(*Theorem decode_parallel_turbo_code_a_posteriori:
  (decode_parallel_turbo_code rs)
Proof
QED*)


val _ = export_theory();
