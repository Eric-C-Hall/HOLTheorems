(* Written by Eric Hall, under the guidance of Michael Norrish *)

open HolKernel Parse boolLib bossLib;

open probabilityTheory;
open measureTheory;
open extrealTheory;
open realTheory;
open cardinalTheory;
open pred_setTheory;

open realLib;

val _ = new_theory "ecc_prob_space";

(* -------------------------------------------------------------------------- *)
(* Some of these concepts were moved here from Practice/block_codesScript.sml,*)
(* which may still contain useful theorems, etc.                              *)
(* -------------------------------------------------------------------------- *)

Overload length_n_codes = “λn. {c : bool list | LENGTH c = n}”;

(* -------------------------------------------------------------------------- *)
(* A uniform distribution on the possible binary strings of length n.         *)
(*                                                                            *)
(* We expect the initial message that was sent to have this kind of           *)
(* distribution. If this were not the case, then we would be able to compress *)
(* the message further using the patterns in the data, until eventually we    *)
(* get to a point where the only information remaining is a series of         *)
(* completely random bits.                                                    *)
(*                                                                            *)
(* n: the length of the binary string                                         *)
(* -------------------------------------------------------------------------- *)
Definition binary_string_uniform_prob_space_def:
  binary_string_uniform_prob_space (n : num) =
  let s = length_n_codes n in
    let a = POW s in
      let p = uniform_distribution (s, a) in
        (s, a, p)
End

(* -------------------------------------------------------------------------- *)
(* The probability mass function of a sequence of errors applied by a binary  *)
(* symmetric channel.                                                         *)
(*                                                                            *)
(* p: the probability of an error being applied to a given bit                *)
(* bs: the bitstring of errors                                                *)
(* -------------------------------------------------------------------------- *)
Definition sym_noise_mass_func_def:
  sym_noise_mass_func (p : extreal) [] = Normal 1 ∧
  sym_noise_mass_func (p : extreal) (b::bs) =
  (if b then p else 1 - p) * sym_noise_mass_func p bs
End

(* -------------------------------------------------------------------------- *)
(* The probability distribution over possible errors caused by binary         *)
(* symmetric channel.                                                         *)
(*                                                                            *)
(* p: the probability of an error being applied to a given bit                *)
(* e (implicit): the event to find the probability for. An event is a set of  *)
(*               possible error patterns.                                     *)
(*                                                                            *)
(* Output: the probability of the given event.                                *)
(* -------------------------------------------------------------------------- *)
Definition sym_noise_dist_def:
  sym_noise_dist (p : extreal) = ∑ (sym_noise_mass_func p)
End

(* -------------------------------------------------------------------------- *)
(* The probability space of possible error patterns generated by a binary     *)
(* symmetric channel.                                                         *)
(*                                                                            *)
(* n: the length of the error pattern                                         *)
(* p: the probability of an error in a given bit                              *)
(* -------------------------------------------------------------------------- *)
Definition sym_noise_prob_space_def:
  sym_noise_prob_space (n : num) (p : extreal)  =
  let sample_space = length_n_codes n in
    let event_space = POW sample_space in
      let prob_dist = sym_noise_dist p in
        (sample_space, event_space, prob_dist)
End

(* -------------------------------------------------------------------------- *)
(* The probability space of an n-bit message that is encoded to become an     *)
(* m-bit message and then sent across a binary symmetric channel with error   *)
(* probability p.                                                             *)
(*                                                                            *)
(* n: the length of the initial message                                       *)
(* m: the length of the message sent across the binary symmetric channel      *)
(* p: the probability of an error in a given bit                              *)
(* -------------------------------------------------------------------------- *)
Definition ecc_bsc_prob_space_def:
  ecc_bsc_prob_space n m p =
  ((binary_string_uniform_prob_space n) × (sym_noise_prob_space m p))
End

Theorem FINITE_IN_POW:
  ∀s : α -> bool.
    ∀ s' : α -> bool.
      FINITE s ∧
      s' ∈ POW s ⇒
      FINITE s'
Proof
  rpt strip_tac
  >> gvs[POW_DEF]
  >> drule SUBSET_FINITE
  >> gvs[]
QED

Theorem uniform_distribution_finite_prob_space:
  ∀s : α -> bool.
    FINITE s ⇒
    CARD s ≠ 0 ⇒
    prob_space (s, POW s, uniform_distribution (s, POW s))
Proof
  rpt strip_tac
  >> irule $ iffRL prob_on_finite_set
  >> rpt strip_tac >> gvs[]
  >- (gvs[additive_def]
      >> rpt strip_tac
      >> gvs[uniform_distribution_def]
      >> qsuff_tac `&CARD (s' ∪ t) : extreal = &CARD(s') + &CARD(t)`
      >- (rpt strip_tac
          >> irule EQ_SYM
          >> pop_assum (fn th => PURE_REWRITE_TAC [th])
          >> irule div_add
          >> gvs[extreal_of_num_def])
      >> qspecl_then [`s'`, `t`] assume_tac CARD_DISJOINT_UNION
      >> drule FINITE_IN_POW >> strip_tac
      >> gvs[DISJOINT_DEF, FINITE_IN_POW]
      >> pop_assum kall_tac >> pop_assum kall_tac
      >> gvs[REAL_ADD, extreal_of_num_def, extreal_add_eq])
  >- (gvs[positive_def]
      >> conj_tac >> gvs[uniform_distribution_def]
      >- gvs[REAL_DIV_LZERO, extreal_of_num_def, extreal_div_eq]
      >> rpt strip_tac
      >> gvs[REAL_LE_DIV, extreal_of_num_def, extreal_div_eq])
  >> gvs[prob_def, p_space_def]
  >> gvs[uniform_distribution_def]
  >> gvs[extreal_of_num_def, extreal_div_eq, REAL_DIV_REFL]
QED

(* ------------------------------------------------------- *)
(* Potentially useful here:                                *)
(* prob_on_finite_set                                      *)
(* uniform_distribution_prob_space                         *)
(* ------------------------------------------------------- *)
Theorem binary_string_uniform_prob_space_is_prob_space:
  ∀n : num.
    prob_space (binary_string_uniform_prob_space n)
Proof
  rpt strip_tac
  >> gvs[binary_string_uniform_prob_space_def]
  >> irule uniform_distribution_finite_prob_space
  >> gvs[]
  >> qspecl_then [`n`] assume_tac length_n_codes_finite
  >> qspecl_then [`n`] assume_tac length_n_codes_cardinality
  >> qspecl_then [`n`, `1`] assume_tac ZERO_LESS_EXP
  >> asm_simp_tac arith_ss []
QED


val _ = export_theory();
