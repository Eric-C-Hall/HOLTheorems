(* Written by Eric Hall, under the guidance of Michael Norrish *)

open HolKernel Parse boolLib bossLib;

val _ = new_theory "ecc_prob_space";

open arithmeticTheory;
open realTheory;
open listTheory;
open pred_setTheory;
open probabilityTheory;
open bitstringTheory;
open metricTheory;
open measureTheory;
open sigma_algebraTheory;
open extreal_baseTheory;
open cardinalTheory;
open extrealTheory;
open combinTheory; (* o_DEF *)
open realTheory;
open iterateTheory;
open realaxTheory;
open real_sigmaTheory;
open bitstringTheory;
open rich_listTheory;
open pairTheory;
open relationTheory;
open wellorderTheory;
open martingaleTheory;
open lebesgueTheory;
open prim_recTheory;
open dividesTheory;
open bitTheory;

open RealArith;

open jared_yeager_prob_space_product_spaceTheory;
(*open WFTheoremsTheory;*)

open ConseqConv;
open dep_rewrite;
open simpLib;

open realLib;

val _ = hide "S";

Overload length_n_codes = ‚ÄúŒªn. {c : bool list | LENGTH c = n}‚Äù;

(* -------------------------------------------------------------------------- *)
(* A uniform distribution on the possible binary strings of length n.         *)
(*                                                                            *)
(* We expect the initial message that was sent to have this kind of           *)
(* distribution. If this were not the case, then we would be able to compress *)
(* the message further using the patterns in the data, until eventually we    *)
(* get to a point where the only information remaining is a series of         *)
(* completely random bits.                                                    *)
(*                                                                            *)
(* n: the length of the binary string                                         *)
(* -------------------------------------------------------------------------- *)
Definition length_n_codes_uniform_prob_space_def:
  length_n_codes_uniform_prob_space (n : num) =
  let s = length_n_codes n in
    let a = POW s in
      let p = uniform_distribution (s, a) in
        (s, a, p)
End

(* -------------------------------------------------------------------------- *)
(* The probability mass function of a sequence of errors applied by a binary  *)
(* symmetric channel.                                                         *)
(*                                                                            *)
(* p: the probability of an error being applied to a given bit                *)
(* bs: the bitstring of errors                                                *)
(* -------------------------------------------------------------------------- *)
Definition sym_noise_mass_func_def:
  sym_noise_mass_func (p : extreal) [] = Normal 1 ‚àß
  sym_noise_mass_func (p : extreal) (b::bs) =
  (if b then p else 1 - p) * sym_noise_mass_func p bs
End

(* -------------------------------------------------------------------------- *)
(* The probability distribution over possible errors caused by binary         *)
(* symmetric channel.                                                         *)
(*                                                                            *)
(* p: the probability of an error being applied to a given bit                *)
(* e (implicit): the event to find the probability for. An event is a set of  *)
(*               possible error patterns.                                     *)
(*                                                                            *)
(* Output: the probability of the given event.                                *)
(* -------------------------------------------------------------------------- *)
Definition sym_noise_dist_def:
  sym_noise_dist (p : extreal) = ‚àë (sym_noise_mass_func p)
End

(* -------------------------------------------------------------------------- *)
(* The probability space of possible error patterns generated by a binary     *)
(* symmetric channel.                                                         *)
(*                                                                            *)
(* n: the length of the error pattern                                         *)
(* p: the probability of an error in a given bit                              *)
(* -------------------------------------------------------------------------- *)
Definition sym_noise_prob_space_def:
  sym_noise_prob_space (n : num) (p : extreal)  =
  let sample_space = length_n_codes n in
    let event_space = POW sample_space in
      let prob_dist = sym_noise_dist p in
        (sample_space, event_space, prob_dist)
End

(* -------------------------------------------------------------------------- *)
(* The probability space of an n-bit message that is encoded to become an     *)
(* m-bit message and then sent across a binary symmetric channel with error   *)
(* probability p.                                                             *)
(*                                                                            *)
(* n: the length of the initial message                                       *)
(* m: the length of the message sent across the binary symmetric channel      *)
(* p: the probability of an error in a given bit                              *)
(* -------------------------------------------------------------------------- *)
Definition ecc_bsc_prob_space_def:
  ecc_bsc_prob_space n m p =
  ((length_n_codes_uniform_prob_space n) √ó (sym_noise_prob_space m p))
End

Theorem FINITE_IN_POW:
  ‚àÄs : Œ± -> bool.
    ‚àÄ s' : Œ± -> bool.
      FINITE s ‚àß
      s' ‚àà POW s ‚áí
      FINITE s'
Proof
  rpt strip_tac
  >> gvs[POW_DEF]
  >> drule SUBSET_FINITE
  >> gvs[]
QED

Theorem uniform_distribution_finite_prob_space:
  ‚àÄs : Œ± -> bool.
    FINITE s ‚áí
    CARD s ‚â† 0 ‚áí
    prob_space (s, POW s, uniform_distribution (s, POW s))
Proof
  rpt strip_tac
  >> irule $ iffRL prob_on_finite_set
  >> rpt strip_tac >> gvs[]
  >- (gvs[additive_def]
      >> rpt strip_tac
      >> gvs[uniform_distribution_def]
      >> qsuff_tac `&CARD (s' ‚à™ t) : extreal = &CARD(s') + &CARD(t)`
      >- (rpt strip_tac
          >> irule EQ_SYM
          >> pop_assum (fn th => PURE_REWRITE_TAC [th])
          >> irule div_add
          >> gvs[extreal_of_num_def])
      >> qspecl_then [`s'`, `t`] assume_tac CARD_DISJOINT_UNION
      >> drule FINITE_IN_POW >> strip_tac
      >> gvs[DISJOINT_DEF, FINITE_IN_POW]
      >> pop_assum kall_tac >> pop_assum kall_tac
      >> gvs[REAL_ADD, extreal_of_num_def, extreal_add_eq])
  >- (gvs[positive_def]
      >> conj_tac >> gvs[uniform_distribution_def]
      >- gvs[REAL_DIV_LZERO, extreal_of_num_def, extreal_div_eq]
      >> rpt strip_tac
      >> gvs[REAL_LE_DIV, extreal_of_num_def, extreal_div_eq])
  >> gvs[prob_def, p_space_def]
  >> gvs[uniform_distribution_def]
  >> gvs[extreal_of_num_def, extreal_div_eq, REAL_DIV_REFL]
QED

(* -------------------------------------------------------------------------- *)
(* Given a binary code of length n, construct a corresponding subset of       *)
(* {0, 1, ..., n - 1}, given by including the element i if and only if the    *)
(* (n - 1 - i)th element of the binary code is true.                          *)
(* -------------------------------------------------------------------------- *)
Definition code_to_subset_def:
  code_to_subset [] = ‚àÖ ‚àß
  code_to_subset (b::bs) = if b then ((LENGTH bs) INSERT (code_to_subset bs)) else (code_to_subset bs)
End

(* -------------------------------------------------------------------------- *)
(* (subset_to_code n s) is the inverse function of (code_to_subset bs) for    *)
(* length n codes                                                             *)
(* -------------------------------------------------------------------------- *)
Definition subset_to_code_def:
  subset_to_code 0 s = [] ‚àß
  subset_to_code (SUC i) s = (i ‚àà s)::(subset_to_code i s)
End

Theorem subset_to_code_length:
  ‚àÄn : num. ‚àÄs : num -> bool.
              LENGTH (subset_to_code n s) = n
Proof
  strip_tac
  >> Induct_on `n` >> gvs[subset_to_code_def]
QED

Theorem subset_to_code_restrict:
  ‚àÄn : num.
    ‚àÄs : num -> bool.
      subset_to_code n s = subset_to_code n (s ‚à© count n)
Proof
  strip_tac
  >> Induct_on `n`
  >- gvs[subset_to_code_def]
  >> rpt strip_tac
  >> PURE_REWRITE_TAC [subset_to_code_def]
  >> first_assum $ qspec_then `s` assume_tac
  >> pop_assum $ (fn th => PURE_REWRITE_TAC [th])
  >> pop_assum $ qspec_then `s ‚à© count1 n` assume_tac
  >> pop_assum $ (fn th => PURE_REWRITE_TAC [th])
  >> gvs[]
  >> `count1 n ‚à© count n = count n` by gvs[INTER_DEF, count_def, EQ_EXT]
  >> metis_tac[INTER_ASSOC]
QED

Theorem subset_to_code_is_right_inverse:
  ‚àÄn : num.
    ‚àÄs : num -> bool.
      s ‚àà POW(count n) ‚áí
      code_to_subset (subset_to_code n s) = s
Proof
  strip_tac
  >> Induct_on `n`
  >- gvs[POW_DEF, subset_to_code_def, code_to_subset_def]
  >> rpt strip_tac
  >> gvs[subset_to_code_def]
  >> gvs[code_to_subset_def]
  >> Cases_on `n ‚àà s` >> gvs[]
  >- (gvs[subset_to_code_length]
      >> last_x_assum $ qspec_then `s ‚à© count n` assume_tac
      >> gvs[POW_DEF]
      >> PURE_REWRITE_TAC [Once subset_to_code_restrict]
      >> pop_assum $ (fn th => PURE_REWRITE_TAC [th])
      >> irule $ iffRL EXTENSION
      >> rpt strip_tac
      >> Cases_on `x > n`
      >- (gvs[]
          >> CCONTR_TAC
          >> gvs[]
          >> gvs[SUBSET_DEF]
          >> first_x_assum $ qspec_then `x` assume_tac
          >> gvs[])
      >> Cases_on `x = n` >> gvs[])
  >> first_x_assum $ qspec_then `s` assume_tac
  >> gvs[POW_DEF]
  >> pop_assum irule
  >> gvs[SUBSET_DEF]
  >> rpt strip_tac
  >> first_x_assum $ qspec_then `x` assume_tac
  >> gvs[]
  >> Cases_on `x = n` >> gvs[]
QED

Theorem code_to_subset_returns_subset:
  ‚àÄbs : bool list.
    code_to_subset bs ‚àà POW (count (LENGTH bs))
Proof
  rpt strip_tac
  >> Induct_on `bs`
  >- gvs[EMPTY_IN_POW, code_to_subset_def]
  >> rpt strip_tac
  >> gvs[code_to_subset_def]
  >> Cases_on `h`
  >> gvs[]
  >> gvs[POW_DEF]
  >> gvs[SUBSET_DEF]
  >> rpt strip_tac
  >> first_x_assum $ qspecl_then [`x`] assume_tac
  >> gvs[]
QED

(* TODO: x ‚àâ s ‚àß x ‚àâ t can be weakened to x ‚àà s ‚áî x ‚àà t *)
Theorem INSERT_INJECTIVE:
  ‚àÄx : Œ±.
    ‚àÄs t : Œ± -> bool.
      x ‚àâ s ‚àß x ‚àâ t ‚áí
      x INSERT s = x INSERT t ‚áí
      s = t
Proof
  rpt strip_tac
  >> irule EQ_EXT
  >> rpt strip_tac
  >> `x' ‚àà s ‚áî x' ‚àà t` suffices_by gvs[IN_DEF]
  >> Cases_on `x' ‚àà s`
  >- (`x' ‚àà x INSERT s` by gvs[]
      >> `x' ‚àà x INSERT t` by metis_tac[]
      >> Cases_on `x' = x` >> gvs[])
  >> Cases_on `x' = x` >> gvs[]
  >> `x' ‚àâ x INSERT s` by gvs[]
  >> `x' ‚àâ x INSERT t` by metis_tac[]
  >> gvs[INSERT_DEF]
QED

Theorem code_to_subset_injective:
  ‚àÄbs cs : bool list.
    LENGTH bs = LENGTH cs ‚áí
    code_to_subset bs = code_to_subset cs ‚áí bs = cs
Proof
  strip_tac
  >> Induct_on `bs`
  >- gvs[]
  >> rpt strip_tac
  >> Cases_on `cs`
  >- gvs[]
  >> first_x_assum $ qspecl_then [`t`] assume_tac
  >> gvs[]
  >> sg `h ‚áî h'`
  >- (Cases_on `h` >> Cases_on `h'` >> gvs[]
      >- (gvs[code_to_subset_def]
          >> qspecl_then [`t`] assume_tac code_to_subset_returns_subset
          >> `LENGTH t INSERT (code_to_subset bs) ‚àà POW (count (LENGTH t))` by gvs[]
          >> last_x_assum kall_tac >> last_x_assum kall_tac >> last_x_assum kall_tac >> last_x_assum kall_tac
          >> gvs[POW_DEF])
      >- (gvs[code_to_subset_def]
          >> qspecl_then [`bs`] assume_tac code_to_subset_returns_subset
          >> `LENGTH t INSERT (code_to_subset t) ‚àà POW (count (LENGTH t))` by gvs[]
          >> last_x_assum kall_tac >> last_x_assum kall_tac >> last_x_assum kall_tac >> last_x_assum kall_tac
          >> gvs[POW_DEF]))
  >> gvs[]
  >> gvs[code_to_subset_def]
  >> Cases_on `h` >> gvs[]
  >> qspecl_then [`bs`] assume_tac code_to_subset_returns_subset
  >> gvs[POW_DEF]
  >> sg `(LENGTH t) ‚àâ (code_to_subset bs)`
  >- (gvs[SUBSET_DEF]
      >> pop_assum $ qspecl_then [`LENGTH t`] assume_tac
      >> gvs[])
  >> qspecl_then [`t`] assume_tac code_to_subset_returns_subset
  >> gvs[POW_DEF]
  >> sg `LENGTH t ‚àâ (code_to_subset t)`
  >- (gvs[SUBSET_DEF]
      >> pop_assum $ qspecl_then [`LENGTH t`] assume_tac
      >> gvs[])
  >> drule_all INSERT_INJECTIVE >> strip_tac
  >> gvs[]
QED

Theorem code_to_subset_surjective:
  ‚àÄn : num.
    ‚àÄs : num -> bool.
      s ‚àà POW (count n) ‚áí
      ‚àÉbs : bool list. LENGTH bs = n ‚àß code_to_subset bs = s
Proof
  rpt strip_tac
  >> qexists `subset_to_code n s`
  >> gvs[subset_to_code_is_right_inverse, subset_to_code_length]
QED

(* -------------------------------------------------------------------------- *)
(* The set of length n codes can be viewed as corresponding to the power set  *)
(* of a set of cardinality n                                                  *)
(* -------------------------------------------------------------------------- *)
Theorem length_n_codes_power_set_bijection:
  ‚àÄn : num.
    BIJ code_to_subset (length_n_codes n) (POW (count n))
Proof
  rpt strip_tac
  >> gvs[BIJ_DEF]
  >> conj_tac
  >- (gvs[INJ_DEF]
      >> rpt strip_tac
      >- gvs[code_to_subset_returns_subset]
      >> gvs[code_to_subset_injective])
  >> gvs[SURJ_DEF]
  >> rpt strip_tac
  >- gvs[code_to_subset_returns_subset]
  >> gvs[code_to_subset_surjective]
QED

Theorem length_n_codes_finite[simp]:
  ‚àÄn : num.
    FINITE (length_n_codes n)
Proof
  rpt strip_tac
  >> qspec_then `n` assume_tac length_n_codes_power_set_bijection
  >> qmatch_asmsub_abbrev_tac `BIJ f s t`
  >> `‚àÉg. BIJ g t s` by (irule $ iffLR BIJ_SYM >> qexists `f` >> gvs[])
       >> `FINITE t` suffices_by (strip_tac >> drule_all FINITE_BIJ >> gvs[])
       >> unabbrev_all_tac
       >> gvs[FINITE_COUNT, FINITE_POW]
QED

Theorem length_n_codes_cardinality[simp]:
  ‚àÄn : num.
    CARD (length_n_codes n) = 2 ** n
Proof
  rpt strip_tac
  >> qspec_then `n` assume_tac length_n_codes_power_set_bijection
  >> qmatch_asmsub_abbrev_tac `BIJ f s t`
  >> `‚àÉg. BIJ g t s` by (irule $ iffLR BIJ_SYM >> qexists `f` >> gvs[])
       >> `CARD t = 2 ** n` by gvs[CARD_POW, CARD_COUNT, Abbr `t`]
       >> `FINITE t` suffices_by (strip_tac >> drule_all FINITE_BIJ >> gvs[])
       >> unabbrev_all_tac
       >> gvs[FINITE_COUNT, FINITE_POW]
QED

(* ------------------------------------------------------- *)
(* Potentially useful here:                                *)
(* prob_on_finite_set                                      *)
(* uniform_distribution_prob_space                         *)
(* ------------------------------------------------------- *)
Theorem length_n_codes_uniform_prob_space_is_prob_space:
  ‚àÄn : num.
    prob_space (length_n_codes_uniform_prob_space n)
Proof
  rpt strip_tac
  >> gvs[length_n_codes_uniform_prob_space_def]
  >> irule uniform_distribution_finite_prob_space
  >> qspecl_then [`n`] assume_tac length_n_codes_finite
  >> qspecl_then [`n`] assume_tac length_n_codes_cardinality
  >> qspecl_then [`n`, `1`] assume_tac ZERO_LESS_EXP
  >> asm_simp_tac arith_ss []
QED

Theorem le_1_not_posinf:
  ‚àÄe : extreal. e ‚â§ 1 ‚áí e ‚â† +‚àû
Proof
  rpt strip_tac
  >> Cases_on ‚Äòe‚Äô >> gvs[]
QED

Theorem REAL_SUB_ID_UNIQUE[simp]:
  ‚àÄa r : real.
    a - r = a ‚áî r = 0
Proof
  rw[]
  >> EQ_TAC >> gvs[]
  >> rw[]
  >> gvs[real_sub]
  >> ‚Äòa + -r = a + 0‚Äô by metis_tac[REAL_ADD_RID]
  >> gvs[]
QED

Theorem complement_prob_real:
  ‚àÄp : real.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí 0 ‚â§ (1 - p) ‚àß (1 - p) ‚â§ 1
Proof
  rw[]
  >- gvs[REAL_LE_SUB_LADD]
  >> gvs[real_sub]
  >> ‚Äò1 + -p ‚â§ 1 + 0‚Äô suffices_by metis_tac[REAL_ADD_RID]
  >> PURE_REWRITE_TAC[REAL_LE_LADD]
  >> gvs[]
QED

Theorem complement_prob_lt_real:
  ‚àÄp : real.
    0 < p ‚àß p < 1 ‚áí 0 < (1 - p) ‚àß (1 - p) < 1
Proof
  rw[REAL_LT_LE, complement_prob_real]
QED

Theorem complement_complement_prob_real:
  ‚àÄp : real.
    1 - (1 - p) = p
Proof
  rw[real_sub, REAL_NEG_ADD, REAL_ADD_ASSOC]
QED

Theorem complement_prob:
  ‚àÄp : extreal.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí 0 ‚â§ (1 - p) ‚àß (1 - p) ‚â§ 1
Proof
  rpt strip_tac
  >- (irule le_sub_imp >> gvs[le_not_infty, le_1_not_posinf])
  >> irule sub_le_imp2
  >> gvs[]
  >> ‚Äò1 + 0 ‚â§ 1 + p‚Äô suffices_by gvs[]
  >> irule $ iffRL le_ladd
  >> gvs[]
QED

Theorem complement_prob_lt:
  ‚àÄp : extreal.
    0 < p ‚àß p < 1 ‚áí 0 < (1 - p) ‚àß (1 - p) < 1
Proof
  Cases_on ‚Äòp‚Äô >> gvs[complement_prob_lt_real, GSYM normal_1, GSYM normal_0,
                      extreal_sub_eq]
QED

Theorem complement_complement_prob:
  ‚àÄp : extreal.
    1 - (1 - p) = p
Proof
  Cases_on ‚Äòp‚Äô >> gvs[complement_prob_lt_real, GSYM normal_1,
                      extreal_sub_eq, complement_complement_prob_real,
                      extreal_sub_def]
QED

Theorem sym_noise_mass_func_nonneg:
  ‚àÄp x. 0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
        0 ‚â§ sym_noise_mass_func p x
Proof
  rpt strip_tac
  >> drule_all complement_prob >> strip_tac
  >> Induct_on ‚Äòx‚Äô >> gvs[sym_noise_mass_func_def, le_mul, pow_pos_le]
  >> rw[]
  >> metis_tac[le_mul, pow_pos_le]
QED

Theorem sym_noise_dist_pos:
  ‚àÄp s. 0 ‚â§ p ‚àß p ‚â§ 1 ‚àß FINITE s ‚áí
        0 ‚â§ sym_noise_dist p s
Proof
  rpt strip_tac
  >> drule_all complement_prob >> strip_tac
  >> gvs[sym_noise_dist_def]
  >> irule EXTREAL_SUM_IMAGE_POS
  >> rpt strip_tac
  >> gvs[sym_noise_mass_func_nonneg]
QED

Theorem sym_noise_dist_not_neginf:
  ‚àÄp s. 0 ‚â§ p ‚àß p ‚â§ 1 ‚àß FINITE s ‚áí
        sym_noise_dist p s ‚â† ‚àí‚àû
Proof
  rpt strip_tac
  >> drule_all sym_noise_dist_pos >> rpt strip_tac
  >> Cases_on ‚Äòsym_noise_dist p s‚Äô >> gvs[]
QED

Theorem sym_noise_dist_singleton:
  ‚àÄp x. 0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
        sym_noise_dist p {x} = sym_noise_mass_func p x
Proof
  rpt strip_tac >> gvs[sym_noise_dist_def]
QED

Theorem mul_to_infty:
  ‚àÄx y.
    ¬¨((x = ‚àí‚àû ‚àß y = +‚àû) ‚à® (x = +‚àû ‚àß y = ‚àí‚àû)) ‚áí
    (x * y = +‚àû ‚áî
       (x = +‚àû ‚àß 0 < y)
       ‚à® (y = +‚àû ‚àß 0 < x)
       ‚à® (x = ‚àí‚àû ‚àß y < 0)
       ‚à® (y = ‚àí‚àû ‚àß x < 0)
    )
Proof
  rw[]
  >> Cases_on ‚Äòx‚Äô >> Cases_on ‚Äòy‚Äô >> gvs[extreal_mul_def]
  >> rw[]
  >> metis_tac[real_lt, REAL_LE_LT, REAL_LT_LE]
QED

Theorem prob_mul_is_prob:
  ‚àÄa b : extreal.
    0 ‚â§ a ‚àß a ‚â§ 1 ‚àß
    0 ‚â§ b ‚àß b ‚â§ 1 ‚áí
    0 ‚â§ (a * b) ‚àß (a * b) ‚â§ 1
Proof
  rw[]
  >> Cases_on ‚Äòa‚Äô >> Cases_on ‚Äòb‚Äô >> gvs[extreal_mul_def]
  >- gvs[REAL_LE_MUL]
  >> sg ‚Äòr * r' ‚â§ r * 1‚Äô
  >- (irule REAL_LE_LMUL_IMP
      >> gvs[]
     )
  >> gvs[]
  >> metis_tac[REAL_LE_TRANS]
QED

Theorem sym_noise_mass_func_prob:
  ‚àÄp x.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    0 ‚â§ sym_noise_mass_func p x ‚àß
    sym_noise_mass_func p x ‚â§ 1
Proof
  rw[] >> gvs[sym_noise_mass_func_nonneg]
  >> Induct_on ‚Äòx‚Äô >> gvs[sym_noise_mass_func_def]
  >> rpt strip_tac
  >> qmatch_goalsub_abbrev_tac ‚Äòa * b ‚â§ 1‚Äô
  >> sg ‚Äò0 ‚â§ a ‚àß a ‚â§ 1 ‚àß 0 ‚â§ b ‚àß b ‚â§ 1‚Äô
  >- (unabbrev_all_tac
      >> rw[]
      >> gvs[complement_prob, sym_noise_mass_func_nonneg]
     )
  >> irule (cj 2 prob_mul_is_prob)
  >> gvs[]
QED

Theorem sym_noise_mass_func_not_inf:
  ‚àÄp x. 0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
        sym_noise_mass_func p x ‚â† +‚àû
Proof
  rw[]
  >> drule_all sym_noise_mass_func_prob
  >> rw[]
  >> CCONTR_TAC >> gvs[]
  >> first_x_assum $ qspec_then ‚Äòx‚Äô assume_tac
  >> gvs[]
QED

Theorem sym_noise_mass_func_not_neginf:
  ‚àÄp x. 0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
        sym_noise_mass_func p x ‚â† ‚àí‚àû
Proof
  gvs[GSYM sym_noise_dist_singleton, sym_noise_dist_not_neginf]
QED

Theorem sym_noise_dist_union:
  ‚àÄp s t.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚àß FINITE s ‚àß FINITE t ‚àß DISJOINT s t ‚áí
    sym_noise_dist p (s ‚à™ t) = sym_noise_dist p s + sym_noise_dist p t
Proof
  rpt strip_tac
  >> gvs[sym_noise_dist_def]
  >> irule EXTREAL_SUM_IMAGE_DISJOINT_UNION
  >> gvs[]
  >> disj1_tac >> gvs[sym_noise_mass_func_not_neginf]
QED

Theorem sym_noise_prob_space_additive:
  ‚àÄn p.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí additive (sym_noise_prob_space n p)
Proof
  rpt strip_tac
  >> drule_all complement_prob >> strip_tac
  >> gvs[additive_def, sym_noise_prob_space_def]
  >> rpt strip_tac
  >> DEP_REWRITE_TAC[sym_noise_dist_union]
  >> metis_tac[FINITE_IN_POW, length_n_codes_finite]
QED

Theorem sym_noise_prob_space_positive:
  ‚àÄn p.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    positive (sym_noise_prob_space n p)
Proof
  rpt strip_tac
  >> drule complement_prob >> strip_tac
  >> gvs[positive_def, sym_noise_prob_space_def]
  >> conj_tac >- gvs[sym_noise_dist_def]
  >> rpt strip_tac
  >> DEP_REWRITE_TAC[sym_noise_dist_pos]
  >> gvs[]
  >> metis_tac[FINITE_IN_POW, length_n_codes_finite]
QED

Theorem sym_noise_prob_space_measure_space:
  ‚àÄn p.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    measure_space (sym_noise_prob_space n p)
Proof
  rpt strip_tac
  >> irule finite_additivity_sufficient_for_finite_spaces2
  >> simp[sym_noise_prob_space_additive, sym_noise_prob_space_positive]
  >> simp[sym_noise_prob_space_def, length_n_codes_finite, POW_SIGMA_ALGEBRA]
QED

Theorem EXTREAL_SUM_IMAGE_DOUB:
  ‚àÄf : Œ± -> extreal.
    ‚àÄa b : Œ±.
      a ‚â† b ‚àß
      ¬¨((f a = +‚àû ‚àß f b = ‚àí‚àû) ‚à® (f a = ‚àí‚àû ‚àß f b = +‚àû)) ‚áí
      ‚àë f {a; b} = f a + f b
Proof
  rpt strip_tac
  >> gvs[EXTREAL_SUM_IMAGE_DEF]
  >> DEP_PURE_ONCE_REWRITE_TAC[ITSET_def]
  >> gvs[REST_DEF, DELETE_DEF]
  >> Cases_on ‚ÄòCHOICE {a; b} = a‚Äô >> gvs[]
  >- (Cases_on ‚Äòf a‚Äô >> Cases_on ‚Äòf b‚Äô >> gvs[extreal_add_def, REAL_ADD_SYM])
  >> Cases_on ‚ÄòCHOICE {a; b} = b‚Äô >> gvs[]
  >> ‚ÄòCHOICE {a; b} ‚àâ {a; b}‚Äô suffices_by gvs[CHOICE_DEF]
  >> CCONTR_TAC
  >> gvs[]
QED

Theorem add_prob_complements:
  ‚àÄp : extreal.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    p + (1 - p) = 1
Proof
  rw[]
  >> DEP_PURE_ONCE_REWRITE_TAC[add_comm]
  >> conj_tac
  >- (Cases_on ‚Äòp‚Äô >> gvs[])
  >> DEP_PURE_ONCE_REWRITE_TAC[sub_add]
  >> gvs[]
  >> Cases_on ‚Äòp‚Äô >> gvs[]
QED

Theorem mul_add_prob_complements:
  ‚àÄp x : extreal.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    p * x + (1 - p) * x = x
Proof
  rw[]
  >> DEP_PURE_ONCE_REWRITE_TAC[GSYM add_rdistrib]
  >> conj_tac
  >- gvs[complement_prob]
  >> gvs[add_prob_complements]
QED

Theorem sym_noise_mass_func_suc:
  ‚àÄp x.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    sym_noise_mass_func p x =
    sym_noise_mass_func p (T::x) + sym_noise_mass_func p (F::x)
Proof
  rpt strip_tac
  >> drule_all complement_prob >> strip_tac
  >> gvs[sym_noise_mass_func_def]
  >> gvs[mul_add_prob_complements]
QED

Theorem sym_noise_dist_suc_singleton:
  ‚àÄp bs.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    sym_noise_dist p {T::bs; F::bs} = sym_noise_dist p {bs}
Proof
  rpt strip_tac
  >> gvs[sym_noise_dist_def]
  >> DEP_PURE_REWRITE_TAC[EXTREAL_SUM_IMAGE_DOUB]
  >> rpt conj_tac
  >- gvs[]
  >- (CCONTR_TAC >> gvs[sym_noise_mass_func_not_neginf])
  >> DEP_PURE_ONCE_REWRITE_TAC[GSYM sym_noise_mass_func_suc]
  >> gvs[]
QED

Theorem sym_noise_dist_insert:
  ‚àÄp x s.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚àß FINITE s ‚àß x ‚àâ s ‚áí
    sym_noise_dist p (x INSERT s) = sym_noise_dist p {x} + sym_noise_dist p s
Proof
  rpt strip_tac
  >> gvs[Once INSERT_SING_UNION]
  >> gvs[sym_noise_dist_union]
QED

Theorem sym_noise_dist_suc_general:
  ‚àÄn p s.
    FINITE s ‚àß
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    sym_noise_dist p (IMAGE (CONS T) s ‚à™ IMAGE (CONS F) s) = sym_noise_dist p s
Proof
  rw[]
  >> NTAC 2 $ pop_assum mp_tac >> SPEC_ALL_TAC
  >> Induct_on ‚Äòs‚Äô using FINITE_INDUCT
  >> rw[]
  >> last_x_assum drule_all
  >> rw[]
  (* Take out the inserted element in the smaller set *)
  >> DEP_PURE_ONCE_REWRITE_TAC[sym_noise_dist_insert]
  >> conj_tac
  >- gvs[]
  (* Take out the first inserted element in the larger set *)
  >> gvs[INSERT_UNION]
  >> DEP_PURE_ONCE_REWRITE_TAC[sym_noise_dist_insert]
  >> conj_tac
  >- gvs[]
  (* Take out the second inserted element in the larger set *)
  >> PURE_ONCE_REWRITE_TAC[UNION_COMM]
  >> gvs[INSERT_UNION]
  >> PURE_ONCE_REWRITE_TAC[UNION_COMM]
  >> qmatch_goalsub_abbrev_tac ‚Äòdonotrewrite + _ = _‚Äô
  >> DEP_PURE_ONCE_REWRITE_TAC[sym_noise_dist_insert]
  >> unabbrev_all_tac
  >> conj_tac
  >- gvs[]
  (* We're almost there *)
  >> gvs[]
  >> DEP_PURE_ONCE_REWRITE_TAC[add_assoc]
  >> conj_tac
  >- (gvs[sym_noise_dist_singleton]
      >> gvs[sym_noise_mass_func_not_neginf]
      >> gvs[sym_noise_mass_func_not_inf]
     )
  >> gvs[sym_noise_dist_singleton]
  >> gvs[GSYM sym_noise_mass_func_suc]
QED

Theorem length_n_codes_suc:
  ‚àÄn : num.
    length_n_codes (SUC n) =
    (IMAGE (CONS T) (length_n_codes n)) ‚à™ (IMAGE (CONS F) (length_n_codes n))
Proof
  strip_tac
  >> irule $ iffRL EXTENSION
  >> rpt strip_tac
  >> gvs[]
  >> EQ_TAC
  >- (rw[]
      >> Cases_on ‚Äòx‚Äô >> gvs[]
     )
  >> rw[]
  >> gvs[LENGTH_CONS]
QED

Theorem sym_noise_dist_suc:
  ‚àÄn p bs.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    sym_noise_dist p (length_n_codes (SUC n)) =
    sym_noise_dist p (length_n_codes n)
Proof
  rpt strip_tac
  >> gvs[length_n_codes_suc]
  >> irule sym_noise_dist_suc_general
  >> gvs[]
QED

Theorem sym_noise_dist_length_n_codes:
  ‚àÄn p.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    sym_noise_dist p (length_n_codes n) = 1
Proof
  rw[]
  >> Induct_on ‚Äòn‚Äô
  >- gvs[sym_noise_dist_def, sym_noise_mass_func_def]
  >> drule EQ_SYM >> pop_assum kall_tac >> strip_tac
  >> pop_assum $ (fn th => PURE_REWRITE_TAC [th])
  (* The probability of the two bitstrings [0, 1, 0] and [1, 1, 0]
     corresponds to the probability of the bitstring [1, 0], for example *)
  >> gvs[sym_noise_dist_suc]
QED

Theorem sym_noise_prob_space_is_prob_space:
  ‚àÄn p.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    prob_space (sym_noise_prob_space n p)
Proof
  rpt strip_tac
  >> drule_all complement_prob >> strip_tac
  >> ‚Äòp ‚â† ‚àí‚àû‚Äô by gvs[le_not_infty]
  >> ‚Äòp ‚â† +‚àû‚Äô by gvs[le_1_not_posinf]
  >> ‚Äò1 - p ‚â† ‚àí‚àû‚Äô by gvs[le_not_infty]
  >> ‚Äò1 - p ‚â† +‚àû‚Äô by gvs[le_1_not_posinf]
  >> gvs[prob_space_def]
  >> gvs[sym_noise_prob_space_measure_space]
  >> gvs[sym_noise_prob_space_def]
  >> gvs[sym_noise_dist_length_n_codes]
QED

Theorem ecc_bsc_prob_space_is_prob_space[simp]:
  ‚àÄn m p.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí
    prob_space (ecc_bsc_prob_space n m p)
Proof
  rw[]
  >> gvs[ecc_bsc_prob_space_def]
  >> irule prob_space_product_space
  >> gvs[length_n_codes_uniform_prob_space_is_prob_space,
         sym_noise_prob_space_is_prob_space]
QED

Theorem sigma_algebra_union_split:
  ‚àÄs a s1 s2.
    sigma_algebra (s, a) ‚àß
    s1 ‚àà a ‚àß
    s2 ‚àà a ‚áí
    s1 ‚à™ s2 ‚àà a
Proof
  rw[]
  >> qspecl_then [‚Äò(s,a)‚Äô, ‚Äòs1‚Äô, ‚Äòs2‚Äô] assume_tac SIGMA_ALGEBRA_UNION
  >> gvs[]
QED

(* -------------------------------------------------------------------------- *)
(* It isn't true that the setwise product of two power sets is the power set  *)
(* of the products, but it is true that the sigma-product of two power sets   *)
(* is the power set of the products, where the sigma-product is the sigma     *)
(* closure of the setwise product.                                            *)
(*                                                                            *)
(* I'm not sure if this holds in the non-finite case. I prove it only in the  *)
(* finite case. I believe it should be relatively straightforward to prove in *)
(* the countable case, because we can then use the fact that the union of     *)
(* countably many elements of the set is in the set, and any subset of the    *)
(* product set can be written as the union of countably many single elements, *)
(* and each single element is directly in the product set. I think it's most  *)
(* likely that this doesn't hold in the uncountable case, but I haven't       *)
(* proved this. However, even in the uncountable case, the sigma-product of   *)
(* two Borel sigma-algebras is the Borel sigma-algebra of the product of the  *)
(* underlying sets.                                                           *)
(* -------------------------------------------------------------------------- *)
Theorem finite_sigma_prod_sets_pow:
  ‚àÄs t.
    FINITE s ‚àß FINITE t ‚áí
    sigma (s √ó t) (prod_sets (POW s) (POW t)) = (s √ó t, POW (s √ó t))
Proof
  (* Break down definitions of sigma and prod_sets *)
  rw[]
  >> gvs[prod_sets_def]
  >> gvs[sigma_def]
  (* Two sets are equal if each is a subset of the other*)
  >> gvs[GSYM SUBSET_ANTISYM_EQ]
  >> conj_tac
  (* The power set is a sigma algebra, thus the intersection of all sigma
     algebras is certainly a subset of the power set *)
  >- (irule BIGINTER_SUBSET
      >> qexists ‚ÄòPOW (s √ó t)‚Äô
      >> gvs[]
      >> conj_tac
      >- (gvs[SUBSET_DEF]
          >> rw[]
          >> gvs[CROSS_DEF, POW_DEF, SUBSET_DEF]
         )
      >> gvs[POW_SIGMA_ALGEBRA]
     )
  (* Break down some definitions *)
  >> gvs[Once SUBSET_DEF]
  >> rw[]
  >> gvs[Once POW_DEF]
  (* We have an arbitrary subset of the product set. This may not be an element
     of the product of the two power sets. For example, {(a,b), (c,d)} is not
     (for a ‚â† c and b ‚â† d), because we would expect this to be the product
     of {a, c} and {b, d}, but in reality this product would be
     {(a,b), (a,d), (c,b), (c,d)}. However, since we are dealing with countable
     sets, it is the countable union of its individual elements, and each
     individual element is in the product of the power sets. Thus, our subset
     is contained in the sigma-closure of the product of the power sets.
.
     In order to take this countable union, it is convenient to perform
     induction over the subset we are working with. So the first step is to
     prove that the subset we are working with is finite *)
  >> ‚ÄòFINITE x‚Äô by metis_tac[CARD_MUL_FINITE, SUBSET_FINITE]
  >> qpat_x_assum ‚ÄòFINITE s‚Äô kall_tac >> qpat_x_assum ‚ÄòFINITE t‚Äô kall_tac
  >> NTAC 3 $ last_x_assum mp_tac
  >> Induct_on ‚Äòx‚Äô
  >> rw[]
  >- (gvs[SUBSET_DEF]
      >> pop_assum irule
      >> qexistsl [‚Äò‚àÖ‚Äô, ‚Äò‚àÖ‚Äô]
      >> gvs[]
     )
  >> gvs[]
  >> PURE_ONCE_REWRITE_TAC[INSERT_SING_UNION]
  >> irule sigma_algebra_union_split
  >> conj_tac >- metis_tac[]
  >> Cases_on ‚Äòe‚Äô >> gvs[]
  >> gvs[SUBSET_DEF]
  >> last_x_assum irule
  >> qexistsl [‚Äò{q}‚Äô, ‚Äò{r}‚Äô]
  >> gvs[POW_DEF]
QED

Theorem prod_sigma_pow:
  ‚àÄs t.
    FINITE s ‚àß FINITE t ‚áí
    (s, POW s) √ó (t, POW t) = (s √ó t, POW (s √ó t))
Proof
  rw[prod_sigma_def, finite_sigma_prod_sets_pow]
QED

Theorem events_ecc_bsc_prob_space:
  ‚àÄn m p.
    events (ecc_bsc_prob_space n m p) =
    POW (length_n_codes n √ó length_n_codes m)
Proof
  rw[]
  >> gvs[ecc_bsc_prob_space_def]
  >> gvs[prod_measure_space_def]
  >> gvs[length_n_codes_uniform_prob_space_def, sym_noise_prob_space_def]
  >> gvs[prod_sigma_pow]        
  >> gvs[events_def]
QED

(* -------------------------------------------------------------------------- *)
(* Any event in our probability space is finite                               *)
(* -------------------------------------------------------------------------- *)
Theorem event_ecc_bsc_prob_space_finite:
  ‚àÄn m p S.
    S ‚àà events (ecc_bsc_prob_space n m p) ‚áí FINITE S
Proof
  rw[events_ecc_bsc_prob_space, POW_DEF]
  >> metis_tac[length_n_codes_finite, FINITE_CROSS, SUBSET_FINITE_I]
QED

(* -------------------------------------------------------------------------- *)
(* Induction rule over a set given that it is contained in a sigma-closure:   *)
(* If a property is true of any element of the initial set, and it is true of *)
(* any countable union of sets satisfying that property, and it is true of    *)
(* any complement of a set satisfying that property, then it is true of all   *)
(* sets in the sigma-closure.                                                 *)
(*                                                                            *)
(* We already have sigma_sets_ind, but this only works on sigma_sets, not on  *)
(* sigma                                                                      *)
(* -------------------------------------------------------------------------- *)
Theorem sigma_induct:
  ‚àÄP sp sts.
    sts ‚äÜ POW sp ‚àß
    P ‚àÖ ‚àß
    (‚àÄs. s ‚àà sts ‚áí P s) ‚àß
    (‚àÄs. P s ‚áí P (sp DIFF s)) ‚àß
    (‚àÄS. (‚àÄs. s ‚àà S ‚áí P s) ‚àß countable S ‚áí P (BIGUNION S)) ‚áí
    (‚àÄs. s ‚àà subsets (sigma sp sts) ‚áí P s)
Proof
  (* In the intersection defined by sigma, use the sigma_algebra
     sigma_sets sp sts, which is the sigma algebra generated from sts in an
     upwards direction, whereas sigma generates it in a downwards direction *)
  rw[]
  >> gvs[sigma_def]
  >> pop_assum $ qspec_then ‚Äòsigma_sets sp sts‚Äô assume_tac
  >> gvs[sigma_algebra_sigma_sets]
  >> gvs[sigma_sets_superset_generator]
  (* Induct on sigma_sets *)
  >> gvs[IN_DEF]
  >> rpt $ last_x_assum mp_tac
  >> Induct_on ‚Äòsigma_sets‚Äô using sigma_sets_ind
  >> rw[] >> gvs[]
  (* The necessary base/inductive steps were mostly proved automatically, but
     it failed in the case of BIGUNION. Apply the BIGUNION inductive rule
     manually *)
  >> last_x_assum irule
  >> rw[] >- metis_tac[]
  (* All we need to do is to prove that this set is countable *)
  >> gvs[COUNTABLE_AS_IMAGE_SUBSET_EQ]
  >> qexists ‚ÄòA‚Äô
  >> ASM_SET_TAC[]
QED

(* -------------------------------------------------------------------------- *)
(* A stronger version of sigma_induct which only requires the inductive steps *)
(* to hold when we are given sets in the space.                               *)
(* -------------------------------------------------------------------------- *)
Theorem sigma_induct_in_space:
  ‚àÄP sp sts.
    P ‚àÖ ‚àß
    (‚àÄs. s ‚àà sts ‚áí P s ‚àß s ‚äÜ sp) ‚àß
    (‚àÄs. P s ‚àß s ‚äÜ sp ‚áí P (sp DIFF s)) ‚àß
    (‚àÄS. (‚àÄs. s ‚àà S ‚áí P s ‚àß s ‚äÜ sp) ‚àß countable S ‚áí P (BIGUNION S)) ‚áí
    (‚àÄs. s ‚àà subsets (sigma sp sts) ‚áí P s)
Proof
  rw[]
  >> qspecl_then [‚ÄòŒªs. P s ‚àß s ‚äÜ sp‚Äô, ‚Äòsp‚Äô, ‚Äòsts‚Äô] assume_tac sigma_induct
  >> gvs[]
  >> qsuff_tac ‚ÄòP s ‚àß s ‚äÜ sp‚Äô >- gvs[]
  >> pop_assum irule
  >> REVERSE $ rw[]
  >- ASM_SET_TAC[POW_DEF]
  >> gvs[BIGUNION_SUBSET]
QED

(* -------------------------------------------------------------------------- *)
(* I think this theorem is false. It is supposed to show that the projection  *)
(* of a measurable set onto one of its components is measurable.              *)
(* -------------------------------------------------------------------------- *)
(*Theorem image_fst_measurable_sets:
  ‚àÄs m1 m2.
    s ‚àà measurable_sets (m1 √ó m2) ‚áí
    (IMAGE FST s ‚àà measurable_sets m1 ‚àß
     IMAGE SND s ‚àà measurable_sets m2)
Proof
  rw[]
  >- (gvs[prod_measure_space_def]
      >> gvs[prod_sigma_def]
      >> qspecl_then [‚ÄòŒªs. IMAGE FST s ‚àà measurable_sets m1‚Äô,
                      ‚Äòm_space m1 √ó m_space m2‚Äô,
                      ‚Äòprod_sets (measurable_sets m1) (measurable_sets m2)‚Äô]
                     assume_tac sigma_induct_in_space
      >> gvs[]
      >> pop_assum irule
      >> rw[]
     )
QED*)

(* -------------------------------------------------------------------------- *)
(* I think this theorem is false. It is supposed to show that the product     *)
(* measure on a set is zero if and only if one of its projections is zero.    *)
(* I'm not sure if it's true or not.                                          *)
(* -------------------------------------------------------------------------- *)
(*Theorem prod_measure_zero:
  ‚àÄm1 m2 e.
    measure_space m1 ‚àß
    measure_space m2 ‚àß
    e ‚àà measurable_sets (m1 √ó m2) ‚áí
    (prod_measure m1 m2 e = 0 ‚áî measure$measure m1 (IMAGE FST e) = 0 ‚à®
                                measure$measure m2 (IMAGE SND e) = 0)
Proof
  rw[]
  >> REVERSE EQ_TAC
  >- (rw[prod_measure_def]
      >- (pop_assum mp_tac
          >> DEP_PURE_ONCE_REWRITE_TAC[GSYM pos_fn_integral_indicator]
          >> gvs[]
          >> gvs[prod_measure_space_def]
         )
      >> gvs[Once pos_fn_integral_def]
      >> gvs[psfis_def]
     )
QED*)

Theorem prob_insert:
  ‚àÄp x xs.
    prob_space p ‚àß
    {x} ‚àà events p ‚àß
    xs ‚àà events p ‚àß
    x ‚àâ xs ‚áí
    prob p (x INSERT xs) = prob p {x} + prob p xs
Proof
  rw[]
  >> irule PROB_ADDITIVE
  >> gvs[]
  >> gvs[INSERT_UNION]
QED

Theorem extreal_pos_add_zero:
  ‚àÄx1 x2 : extreal.
    0 ‚â§ x1 ‚àß
    0 ‚â§ x2 ‚áí
    (x1 + x2 = 0 ‚áî x1 = 0 ‚àß x2 = 0)
Proof
  rw[]
  >> Cases_on ‚Äòx1‚Äô >> Cases_on ‚Äòx2‚Äô >> gvs[extreal_add_def]
  >> gvs[REAL_LNEG_UNIQ]
  >> EQ_TAC >> gvs[]
  >> rw[]
  >> gvs[]
  >> metis_tac[REAL_LE_ANTISYM]
QED

Theorem prob_add_zero:
  ‚àÄp e1 e2.
    prob_space p ‚àß
    e1 ‚àà events p ‚àß
    e2 ‚àà events p ‚áí
    (prob p e1 + prob p e2 = 0 ‚áî prob p e1 = 0 ‚àß prob p e2 = 0)
Proof
  rw[]
  >> EQ_TAC >> gvs[]
  >> rw[]
  >> (sg ‚Äò0 ‚â§ prob p e2‚Äô >- gvs[PROB_POSITIVE]
      >> sg ‚Äò0 ‚â§ prob p e1‚Äô >- gvs[PROB_POSITIVE]
      >> gvs[extreal_pos_add_zero])
QED

(* -------------------------------------------------------------------------- *)
(* The product measure of a singleton set is equal to the product of the two  *)
(* measures applied to the projections of that set.                           *)
(*                                                                            *)
(* This is a special case of martingaleTheory.PROD_MEASURE_CROSS, although    *)
(* I didn't realise this before proving it.                                   *)
(* -------------------------------------------------------------------------- *)
Theorem prod_measure_sing:
  ‚àÄm1 m2 x.
    measure_space m1 ‚àß
    measure_space m2 ‚àß
    {FST x} ‚àà measurable_sets m1 ‚àß
    {SND x} ‚àà measurable_sets m2 ‚áí
    prod_measure m1 m2 {x} = measure$measure m1 {FST x} *
                             measure$measure m2 {SND x}
Proof
  rw[]
  >> gvs[prod_measure_def]
  >> sg ‚Äò‚àÄy. ‚à´‚Å∫ m1 (Œªx'. ùüô {x} (x',y)) =
             (if y = SND x then measure$measure m1 {FST x} else 0)‚Äô
  >- (rw[]
      >- (sg ‚Äò(Œªx'. ùüô {x} (x',SND x)) = ùüô {FST x}‚Äô
          >- (gvs[FUN_EQ_THM]
              >> rw[]
              >> Cases_on ‚Äòx‚Äô >> gvs[]
              >> gvs[indicator_fn_def]
             )
          >> gvs[pos_fn_integral_indicator]
         )
      >> gvs[indicator_fn_def]
      >> Cases_on ‚Äòx‚Äô >> gvs[]
      >> gvs[pos_fn_integral_zero]
     )
  >> gvs[] >> pop_assum kall_tac
  >> sg ‚Äò(Œªy. if y = SND x then measure m1 {FST x} else 0) =
         (Œªy. measure m1 {FST x} * ùüô {SND x} y)‚Äô
  >- (gvs[FUN_EQ_THM] >> rw[]
      >> gvs[indicator_fn_def]
     )
  >> gvs[] >> pop_assum kall_tac
  >> Cases_on ‚Äòmeasure m1 {FST x}‚Äô
  >- (qspecl_then [‚Äòm1‚Äô, ‚Äò{FST x}‚Äô] assume_tac MEASURE_POSITIVE
      >> gvs[]
     )
  >- gvs[pos_fn_integral_cmul_infty]
  >> DEP_PURE_ONCE_REWRITE_TAC[pos_fn_integral_cmul_indicator]
  >> gvs[]
  >> qspecl_then [‚Äòm1‚Äô, ‚Äò{FST x}‚Äô] assume_tac MEASURE_POSITIVE
  >> gvs[]
QED

Theorem uniform_distribution_nonzero:
  ‚àÄf s.
    FINITE (space f) ‚àß CARD (space f) ‚â† 0 ‚àß s ‚äÜ space f ‚áí
    (uniform_distribution f s = 0 ‚áî s = ‚àÖ)
Proof
  rw[]
  >> gvs[uniform_distribution_def]
  >> gvs[extreal_of_num_def]
  >> gvs[extreal_div_eq]
  >> sg ‚ÄòFINITE s‚Äô >- metis_tac[SUBSET_FINITE]
  >> Cases_on ‚Äòs‚Äô >> gvs[]
QED

Theorem length_n_codes_empty[simp]:
  ‚àÄn : num. length_n_codes n ‚â† ‚àÖ
Proof
  rpt strip_tac
  >> gvs[EXTENSION]
  >> pop_assum $ qspec_then ‚Äòzero_extend n []‚Äô assume_tac
  >> gvs[length_zero_extend]
QED

Theorem sym_noise_mass_func_neq_zero:
  ‚àÄp bs.
    (sym_noise_mass_func p bs = 0) ‚áî
      (p = 0 ‚àß MEM T bs) ‚à® ((1 - p) = 0 ‚àß MEM F bs)
Proof
  rw[]
  >> EQ_TAC >> gvs[]
  >- (rw[]
      >> Induct_on ‚Äòbs‚Äô >> gvs[sym_noise_mass_func_def]
      >> rw[] >> gvs[])
  >> rw[]
  >> (Induct_on ‚Äòbs‚Äô >> gvs[sym_noise_mass_func_def]
      >> rw[])
QED

(* -------------------------------------------------------------------------- *)
(* An event in ecc_bsc_prob_space has probability zero if and only if it is   *)
(* the empty event, assuming that we aren't in the special case where our     *)
(* binary symmetric channel has probability 0 or 1.                           *)
(* -------------------------------------------------------------------------- *)
Theorem prob_ecc_bsc_prob_space_zero:
  ‚àÄn m p e.
    0 < p ‚àß p < 1 ‚àß
    e ‚àà events (ecc_bsc_prob_space n m p) ‚áí
    (prob (ecc_bsc_prob_space n m p) e = 0 ‚áî e = ‚àÖ)
Proof
  rw[]
  (* The reverse implication follows directly from the definition of
     probabilities, so prove that first *)
  >> REVERSE EQ_TAC
  >- gvs[PROB_EMPTY, ecc_bsc_prob_space_is_prob_space, le_lt]
  >> rw[]
  (* If e is nonempty, it has at least one element. Reduce to the case in which
     we have only one element, since the probability of the entire set is
     certainly at least as great as the probability of one of its elements *)
  >> Cases_on ‚Äòe‚Äô >> gvs[]
  >> sg ‚Äò{x} ‚àà events (ecc_bsc_prob_space n m p)‚Äô
  >- gvs[events_ecc_bsc_prob_space, POW_DEF]
  >> sg ‚Äòt ‚àà events (ecc_bsc_prob_space n m p)‚Äô
  >- gvs[events_ecc_bsc_prob_space, POW_DEF]
  (* Note: I regularly use le_lt to ensure that
     ecc_bsc_prob_space_is_prob_space is applicable *)
  >> gvs[prob_insert, ecc_bsc_prob_space_is_prob_space, le_lt]
  >> gvs[prob_add_zero, ecc_bsc_prob_space_is_prob_space, le_lt]
  >> qpat_x_assum ‚Äòt ‚àà _‚Äô kall_tac
  >> qpat_x_assum ‚Äòx ‚àâ t‚Äô kall_tac
  >> qpat_x_assum ‚Äòx INSERT t ‚àà _‚Äô kall_tac
  >> qpat_x_assum ‚Äòprob _ t = 0‚Äô kall_tac
  (* Now we prove that no singleton event has 0 probability in
     ecc_bsc_prob_space *)
  >> gvs[events_ecc_bsc_prob_space]
  >> gvs[ecc_bsc_prob_space_def]
  >> gvs[prod_measure_space_def]
  >> gvs[length_n_codes_uniform_prob_space_def, sym_noise_prob_space_def]
  >> gvs[prob_def]
  >> qpat_x_assum ‚Äòprod_measure _ _ _ = 0‚Äô mp_tac
  >> DEP_PURE_ONCE_REWRITE_TAC[prod_measure_sing]
  >> gvs[]
  >> rw[]
  >- (qspecl_then [‚Äòn‚Äô] assume_tac length_n_codes_uniform_prob_space_is_prob_space
      >> gvs[prob_space_def, length_n_codes_uniform_prob_space_def])
  >- (qspecl_then [‚Äòm‚Äô, ‚Äòp‚Äô] assume_tac sym_noise_prob_space_is_prob_space
      >> gvs[prob_space_def, sym_noise_prob_space_def, le_lt])
  >- gvs[POW_DEF]
  >- gvs[POW_DEF]
  >- (DEP_PURE_ONCE_REWRITE_TAC[uniform_distribution_nonzero]
      >> gvs[]
      >> gvs[POW_DEF]
     )
  >> gvs[sym_noise_dist_def, sym_noise_mass_func_neq_zero]
  >> rw[] >> gvs[]
  >> drule sub_0
  >> rw[] >> gvs[]
QED

Theorem extreal_of_num_suc:
  ‚àÄn : num.
    &(SUC n) : extreal = (&n) + 1
Proof
  rw[]
  >> gvs[extreal_of_num_def]
  >> PURE_ONCE_REWRITE_TAC[GSYM REAL_OF_NUM_SUC]
  >> metis_tac[extreal_add_eq]
QED

Theorem extreal_of_num_add:
  ‚àÄn m : num.
    &(n + m) : extreal = (&n) + (&m)
Proof
  rpt strip_tac
  >> Induct_on ‚Äòn‚Äô
  >- gvs[]
  >> gvs[ADD]
  >> gvs[extreal_of_num_suc]
  >> Cases_on ‚Äò&n : extreal‚Äô >> Cases_on ‚Äò&m : extreal‚Äô >> gvs[]
  >> rpt (pop_assum kall_tac)
  >> ‚Äò1 = Normal 1‚Äô by gvs[]
  >> pop_assum (fn th => PURE_REWRITE_TAC[th])
  >> PURE_REWRITE_TAC[extreal_add_eq]
  >> gvs[extreal_11]
  >> metis_tac[REAL_ADD_COMM, REAL_ADD_ASSOC]
QED

Theorem extreal_of_num_mul:
  ‚àÄn m : num.
    &(n * m) : extreal = (&n) * (&m)
Proof
  rw[]
  >> Induct_on ‚Äòm‚Äô >> gvs[]
  >> gvs[MULT_SUC]
  >> gvs[extreal_of_num_add]
  >> pop_assum kall_tac
  >> gvs[extreal_of_num_suc]
  >> Cases_on ‚Äò&n : extreal‚Äô >> Cases_on ‚Äò&m : extreal‚Äô >> gvs[]
  >> rpt (pop_assum kall_tac)
  >> ‚Äò1 = Normal 1‚Äô by gvs[]
  >> pop_assum (fn th => PURE_REWRITE_TAC[th])
  >> PURE_REWRITE_TAC[extreal_add_eq, extreal_mul_eq]
  >> gvs[extreal_11]
  >> gvs[REAL_LDISTRIB]
  >> metis_tac[REAL_ADD_COMM] 
QED

Theorem extreal_of_num_exp:
  ‚àÄn m : num.
    &(n ** m) : extreal = (&n) pow (&m)
Proof
  rw[]
  >> Induct_on ‚Äòm‚Äô >> gvs[]
  >> gvs[EXP]
  >> gvs[extreal_of_num_mul]
  >> pop_assum kall_tac
  >> gvs[extreal_pow]
QED

(* -------------------------------------------------------------------------- *)
(* A version of EXTREAL_SUM_IMAGE_CMUL which has the constant on the other    *)
(* side, and also doesn't assume that the constant takes the form Normal r    *)
(* -------------------------------------------------------------------------- *)
Theorem EXTREAL_SUM_IMAGE_CMUL_R_ALT:
  ‚àÄs. FINITE s ‚áí
      ‚àÄf c.
        c ‚â† +‚àû ‚àß c ‚â† ‚àí‚àû ‚àß
        ((‚àÄx. x ‚àà s ‚áí f x ‚â† ‚àí‚àû) ‚à® (‚àÄx. x ‚àà s ‚áí f x ‚â† +‚àû)) ‚áí
        ‚àë (Œªx. f x * c) s = c * ‚àë f s
Proof
  rw[]
  (* Both proofs are essentially the same *)
  >> (PURE_ONCE_REWRITE_TAC[mul_comm]
      >> Cases_on ‚Äòc‚Äô >> gvs[EXTREAL_SUM_IMAGE_CMUL]
      >> metis_tac[mul_comm]
     )
QED

(* -------------------------------------------------------------------------- *)
(* A version of EXTREAL_SUM_IMAGE_CMUL which doesn't assume that the constant *)
(* takes the form Normal r                                                    *)
(* -------------------------------------------------------------------------- *)
Theorem EXTREAL_SUM_IMAGE_CMUL_L_ALT:
  ‚àÄs. FINITE s ‚áí
      ‚àÄf c.
        c ‚â† +‚àû ‚àß c ‚â† ‚àí‚àû ‚àß
        ((‚àÄx. x ‚àà s ‚áí f x ‚â† ‚àí‚àû) ‚à® (‚àÄx. x ‚àà s ‚áí f x ‚â† +‚àû)) ‚áí
        ‚àë (Œªx. c * f x) s = c * ‚àë f s
Proof
  rw[]
  >> Cases_on ‚Äòc‚Äô >> gvs[EXTREAL_SUM_IMAGE_CMUL]
QED

(* -------------------------------------------------------------------------- *)
(* Since our prob space has a finite event space, we can calculate the        *)
(* probability by simply summing over the probabilities of each individual    *)
(* event.                                                                     *)
(*                                                                            *)
(* Note that the sum makes this expression similar to sym_noise_dist, but not *)
(* easily represented in terms of it.                                         *)
(* -------------------------------------------------------------------------- *)
Theorem prob_ecc_bsc_prob_space:
  ‚àÄn m p S.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚àß
    S ‚àà events (ecc_bsc_prob_space n m p) ‚áí
    prob (ecc_bsc_prob_space n m p) S =
    1 / 2 pow n * ‚àë (sym_noise_mass_func p ‚àò SND) S
Proof
  rw[]
  (* Our event is finite because our space is finite *)
  >> sg ‚ÄòFINITE S‚Äô
  >- (gvs[events_ecc_bsc_prob_space, POW_DEF]
      >> metis_tac[length_n_codes_finite, SUBSET_FINITE, FINITE_CROSS])
  (* It is sometimes convenient to know that S is in the event space, and
     sometimes convenient to know that each component of each element of S
     has the correct length *)
  >> sg ‚ÄòS ‚äÜ length_n_codes n √ó length_n_codes m‚Äô
  >- (gvs[events_ecc_bsc_prob_space]
      >> gvs[POW_DEF])
  (* The probability of a finite set is equivalent to taking the sum over
     the probabilities of each of the elements in the finite set *)
  >> DEP_PURE_ONCE_REWRITE_TAC[PROB_EXTREAL_SUM_IMAGE]
  >> gvs[ecc_bsc_prob_space_is_prob_space]
  >> conj_tac
  >- (rw[]
      >> gvs[events_ecc_bsc_prob_space]
      >> gvs[POW_DEF]
      >> ‚Äòx ‚àà length_n_codes n √ó length_n_codes m‚Äô by ASM_SET_TAC[]
      >> gvs[]
     )
  (* We can use prod_measure_sing to simplify the probability function, because
     it is being applied to a single element. *)
  >> simp[ecc_bsc_prob_space_def, prod_measure_space_def,
          prob_def]
  >> qspecl_then [‚ÄòŒªx. prod_measure (length_n_codes_uniform_prob_space n)
                                    (sym_noise_prob_space m p) {x}‚Äô,
                  ‚ÄòŒªx. (measure (length_n_codes_uniform_prob_space n) {FST x}) *
                       (measure (sym_noise_prob_space m p) {SND x})‚Äô,
                  ‚ÄòS‚Äô] assume_tac EXTREAL_SUM_IMAGE_EQ'
  >> pop_assum (fn th => DEP_PURE_ONCE_REWRITE_TAC[th])
  >> rw[]
  (* Apply prod_measure_sing to simplify the product measure *)
  >- (DEP_PURE_ONCE_REWRITE_TAC[prod_measure_sing]
      >> gvs[length_n_codes_uniform_prob_space_is_prob_space,
             sym_noise_prob_space_is_prob_space,
             prob_space_def]
      >> rw[]
           >>~- ([‚Äòmeasure_space _‚Äô] ,
                 metis_tac[length_n_codes_uniform_prob_space_is_prob_space,
                           sym_noise_prob_space_is_prob_space,
                           prob_space_def])
           >>~- ([‚Äò_ ‚àà measurable_sets _‚Äô],
                 ‚Äòx ‚àà length_n_codes n √ó length_n_codes m‚Äô by ASM_SET_TAC[]
                 >> Cases_on ‚Äòx‚Äô >> gvs[]
                 >> gvs[length_n_codes_uniform_prob_space_def,
                        sym_noise_prob_space_def]
                 >> gvs[POW_DEF, CROSS_DEF]
                )
     )
  (* Simplify the expression within the sum *)
  >> gvs[length_n_codes_uniform_prob_space_def, uniform_distribution_def]
  >> gvs[extreal_of_num_exp]
  >> gvs[sym_noise_prob_space_def]
  >> gvs[sym_noise_dist_def]
  (* Take the 1 / 2 out the front *)
  >> DEP_PURE_ONCE_REWRITE_TAC[EXTREAL_SUM_IMAGE_CMUL_L_ALT]
  >> rw[]
  >- (Cases_on ‚Äò1 : extreal‚Äô >> gvs[]
      >> irule (cj 1 div_not_infty)
      >> CCONTR_TAC
      >> gvs[]
      >> drule pow_zero_imp
      >> gvs[]
     )
  >- (Cases_on ‚Äò1 : extreal‚Äô >> gvs[]
      >> irule (cj 2 div_not_infty)
      >> CCONTR_TAC
      >> gvs[]
      >> drule pow_zero_imp
      >> gvs[]
     )
  >- (disj1_tac
      >> rw[]
      >> gvs[sym_noise_mass_func_not_neginf]
     )
  (* Transform to composition *)
  >> gvs[o_DEF]
QED

(* -------------------------------------------------------------------------- *)
(* Things below this line are somewhat outdated, but may be useful at some    *)
(* point                                                                      *)
(* -------------------------------------------------------------------------- *)

(* -------------------------------------------------------------------------- *)
(* Notes on relevant theorems, etc                                            *)
(*                                                                            *)
(* UNIV_SIGMA_ALGEBRA, sigma_algebra, ùïå                                      *)
(*                                                                            *)
(* uniform_distribution, distribution, conditional_distribution               *)
(*                                                                            *)
(* algebra                                                                    *)
(*                                                                            *)
(* subsets, space                                                             *)
(* -------------------------------------------------------------------------- *)

Definition hamming_distance_def:
  hamming_distance (l1 : Œ± list) (l2 : Œ± list) = FOLDR ($+) 0n (MAP (Œªpair. if (FST pair = SND pair) then 0n else 1n) (ZIP (l1, l2)))
End

Definition hamming_distance_alt_def[simp]:
  hamming_distance_alt [] (l2 : Œ± list) = 0 ‚àß
  hamming_distance_alt (h1::t1 : Œ± list) (h2::t2 : Œ± list) =
  (if (h1 = h2) then 0n else 1n) + hamming_distance_alt t1 t2
End

Theorem hamming_distance_empty[simp]:
  ‚àÄcs. hamming_distance [] [] = 0
Proof
  gvs[hamming_distance_def]
QED

Theorem hamming_distance_cons[simp]:
  ‚àÄb bs c cs.
    hamming_distance (b::bs) (c::cs) = (if b = c then 0 else 1) + hamming_distance bs cs
Proof
  rpt strip_tac
  >> gvs[hamming_distance_def]
QED

Theorem hamming_distance_alt_equivalent:
  ‚àÄbs cs.
    LENGTH bs = LENGTH cs ‚áí
    hamming_distance bs cs = hamming_distance_alt bs cs
Proof
  strip_tac
  >> Induct_on ‚Äòbs‚Äô >> gvs[]
  >> rpt strip_tac
  >> Cases_on ‚Äòcs‚Äô  >> gvs[]
QED

Definition degenerate_distribution_def:
  degenerate_distribution (x : Œ±) = (Œªs : Œ± -> bool. if x ‚àà s then 1 : extreal else 0 : extreal)
End

Definition length_n_codes_degenerate_prob_space_def:
  length_n_codes_degenerate_prob_space (n : num) (bs : bool list) =
  let s = length_n_codes n in
    let a = POW s in
      let p = degenerate_distribution bs in
        (s, a, p)
End

Theorem DISJOINT_IN:
  ‚àÄs t : Œ± -> bool.
    ‚àÄx : Œ±.
      DISJOINT s t ‚àß x ‚àà s ‚áí x ‚àâ t
Proof
  rpt strip_tac
  >> gvs[DISJOINT_DEF]
  >> gvs[INTER_DEF]
  >> drule $ iffLR EXTENSION >> strip_tac
  >> pop_assum $ qspec_then `x` assume_tac
  >> gvs[]
QED

Theorem SET_REMOVE_ELEMENT:
  ‚àÄs : Œ± -> bool.
    ‚àÄx : Œ±.
      x ‚àà s ‚áí s = {x} ‚à™ (s DIFF {x})
Proof
  rpt strip_tac
  >> gvs[UNION_DEF, DIFF_DEF]
  >> irule EQ_EXT
  >> rpt strip_tac
  >> gvs[IN_DEF]
  >> Cases_on `x' = x` >> gvs[]
QED

Theorem EXTREAL_SUP_POSITIVE_INFINITY:
  ‚àÄs : extreal -> bool.
    sup s = +‚àû ‚áî (‚àÄx. ((‚àÄy. y‚ààs ‚áí y ‚â§ x) ‚áí x = +‚àû))
Proof
  strip_tac
  >> Cases_on `sup s = +‚àû`
  >- (gvs[]
      >> gvs[extreal_sup_def]
      >> qmatch_asmsub_abbrev_tac `if c1 then _ else (if c2 then _ else _)`
      >> Cases_on `c1` >> gvs[IN_DEF]
      >> Cases_on `c2` >> gvs[])
  >> qmatch_goalsub_abbrev_tac `_ ‚áî c1`
  >> gvs[]
  >> CCONTR_TAC
  >> gvs[]
  >> sg `sup s = +‚àû`
  >- (PURE_REWRITE_TAC [Once extreal_sup_def]
      >> gvs[IN_DEF])
QED

Theorem EXTREAL_SUP_NEGATIVE_INFINITY:
  ‚àÄs : extreal -> bool.
    sup s = ‚àí‚àû ‚áî ‚àÄx. x ‚ààs ‚áí x = ‚àí‚àû
Proof
  strip_tac
  >> Cases_on `sup s = ‚àí‚àû`
  >- (gvs[extreal_sup_def]
      >> qmatch_asmsub_abbrev_tac `if c1 then _ else (if c2 then _ else _)`
      >> Cases_on `c1` >> gvs[]
      >> Cases_on `c2` >> gvs[IN_DEF])
  >> qmatch_goalsub_abbrev_tac `_ ‚áî c1`
  >> gvs[]
  >> CCONTR_TAC
  >> gvs[]
  >> sg `sup s = ‚àí‚àû`
  >- (PURE_REWRITE_TAC [Once extreal_sup_def]
      >> qmatch_goalsub_abbrev_tac `if c1 then _ else (if c2 then _ else _)`
      >> Cases_on `c1`
      >- (gvs[]
          >> first_x_assum $ qspecl_then [`0 : extreal`] assume_tac
          >> gvs[]
          >> first_x_assum $ qspec_then `y` assume_tac
          >> gvs[Abbr `c2`, IN_DEF])
      >> gvs[Abbr `c2`, IN_DEF])
QED

Theorem EXTREAL_SUP_NEGATIVE_INFINITY_EMPTY_OR_SINGLETON:
  ‚àÄs : extreal -> bool.
    sup s = ‚àí‚àû ‚áí s = ‚àÖ ‚à® s = {‚àí‚àû}
Proof
  rpt strip_tac
  >> CCONTR_TAC
  >> gvs[]
  >> drule (iffLR EXTREAL_SUP_NEGATIVE_INFINITY) >> strip_tac >> last_x_assum kall_tac
  >> qspecl_then [`s`, `‚àÖ`] assume_tac (iffRL EXTENSION)
  >> `s = ‚àÖ` suffices_by gvs[]
  >> gvs[]
  >> first_assum drule >> strip_tac
  >> last_x_assum kall_tac
  >> qspecl_then [`s`, `{‚àí‚àû}`] assume_tac (iffRL EXTENSION)
  >> `s = {‚àí‚àû}` suffices_by gvs[]
  >> gvs[]
  >> first_x_assum $ qspec_then `x` assume_tac
  >> Cases_on `x ‚àà s` >> gvs[]
QED

Theorem EXTREAL_SUP_NOT_POSITIVE_INFINITY:
  ‚àÄs : extreal -> bool.
    sup s ‚â† +‚àû ‚áí ‚àÉx. (‚àÄy. y ‚àà s ‚áí y ‚â§ x) ‚àß x ‚â† +‚àû
Proof
  rpt strip_tac
  >> qexists `sup s + 1`
  >> conj_tac >> gvs[add_not_infty]
  >> rpt strip_tac
  >> drule le_sup_imp' >> strip_tac
  >> `0 : extreal ‚â§ 1` by gvs[]
  >> `y + 0 ‚â§ sup s + 1` by gvs[le_add2]
  >> gvs[]
QED

Theorem EXTREAL_SUP_NOT_NEGATIVE_INFINITY:
  ‚àÄs : extreal -> bool.
    sup s ‚â† ‚àí‚àû ‚áí ‚àÉx. x ‚àà s ‚àß x ‚â† ‚àí‚àû
Proof
  rpt strip_tac
  >> gvs[extreal_sup_def]
  >> qmatch_asmsub_abbrev_tac `if c1 then _ else (if c2 then _ else v)`
  >> Cases_on `c1`
  >- (gvs[]
      >> first_x_assum $ qspec_then `0` assume_tac
      >> gvs[]
      >> qexists `y`
      >> CCONTR_TAC
      >> gvs[IN_DEF])
  >> gvs[]
  >> Cases_on `c2` >> gvs[]
  >> qexists `x'`
  >> gvs[IN_DEF]
QED

Theorem EXTREAL_SUP_REAL_SUP:
  ‚àÄs : extreal -> bool.
    ‚àÄr : real.
      sup s = Normal r ‚áí sup (PREIMAGE Normal s) = r
Proof
  rpt strip_tac
  >> gvs[extreal_sup_def]
  >> qmatch_asmsub_abbrev_tac `if c1 then _ else (if c2 then _ else v)`
  >> Cases_on `c1` >> gvs[]
  >> Cases_on `c2` >> gvs[]
  >> AP_TERM_TAC
  >> gvs[PREIMAGE_def]
  >> irule EQ_EXT
  >> rpt strip_tac
  >> gvs[IN_DEF]
QED

Theorem EXTREAL_MAX_REAL_MAX:
  ‚àÄr r' : real.
    max (Normal r) (Normal r') = Normal (max r r')
Proof
  rpt strip_tac
  >> gvs[extreal_max_def]
  >> gvs[real_max]
  >> Cases_on `r ‚â§ r'` >> gvs[]
QED

Theorem EXTREAL_SUP_UNION:
  ‚àÄs t : extreal -> bool.
    sup (s ‚à™ t) = max (sup s) (sup t)
Proof
  rpt strip_tac
  (* Strategy: Prove for all cases where sup s/sup t is +‚àû/-‚àû. Then in the
     case where each is finite, prove that sup (s ‚à™ t) is finite. Then
     convert to real and use existing proof for the real version *)
  (* Handle case where either of the supremums is infinity *)
  >> sg ‚Äò‚àÄs t : extreal -> bool. sup s = +‚àû ‚áí sup (s ‚à™ t) = max (sup s) (sup t)‚Äô
  >- (rpt strip_tac
      >> drule (iffLR EXTREAL_SUP_POSITIVE_INFINITY)
      >> rpt strip_tac
      >> gvs[]
      >> PURE_REWRITE_TAC[Once extreal_sup_def]
      >> qmatch_goalsub_abbrev_tac `if c1 then _ else (if c2 then _ else _)`
      >> `c1` suffices_by gvs[]
      >> gvs[Abbr `c1`, Abbr `c2`]
     )
  >> Cases_on ‚Äòsup s = +‚àû‚Äô >> gvs[]
  >> Cases_on ‚Äòsup t = +‚àû‚Äô
  >- (first_x_assum $ qspecl_then [`t`, `s`] assume_tac >> gvs[UNION_COMM])
  >> last_x_assum kall_tac
  (* Handle case where either of the supremums is negative infinity *)
  >> sg ‚Äò‚àÄs t : extreal -> bool. sup s = ‚àí‚àû ‚áí sup (s ‚à™ t) = max (sup s) (sup t)‚Äô
  >- (rpt (pop_assum kall_tac)
      >> rpt strip_tac
      >> gvs[]
      >> PURE_REWRITE_TAC[Ntimes extreal_sup_def 2]
      >> qmatch_goalsub_abbrev_tac `(if c1 then _ else (if c2 then _ else e1)) = (if c3 then _ else (if c4 then _ else e2))`
      >> `c1 = c3 ‚àß c2 = c4 ‚àß e1 = e2` suffices_by gvs[]
      >> conj_tac
      >- (unabbrev_all_tac
          >> qmatch_goalsub_abbrev_tac `b1 ‚áî b2`
          >> Cases_on `b1` >> Cases_on `b2` >> rfs[]
          >- (last_x_assum $ qspec_then `x` assume_tac
              >> gvs[]
              >> last_x_assum $ qspec_then `y` assume_tac
              >> gvs[IN_DEF]
              >> drule $ iffLR EXTREAL_SUP_NEGATIVE_INFINITY >> strip_tac
              >> pop_assum $ qspec_then `y` assume_tac
              >> gvs[IN_DEF])
          >> pop_assum $ qspec_then `x` assume_tac
          >> gvs[]
          >> first_x_assum $ qspec_then `y` assume_tac
          >> gvs[]
          >> drule $ iffLR EXTREAL_SUP_NEGATIVE_INFINITY >> strip_tac
          >> pop_assum $ qspec_then `x` assume_tac
          >> gvs[IN_DEF])
      >> conj_tac
      >- (unabbrev_all_tac
          >> qmatch_goalsub_abbrev_tac `b1 ‚áî b2`
          >> Cases_on `b1` >> Cases_on `b2` >> gvs[]
          >- (first_x_assum $ qspec_then `x` assume_tac
              >> gvs[IN_DEF])
          >- (drule $ iffLR EXTREAL_SUP_NEGATIVE_INFINITY >> strip_tac
              >> pop_assum $ qspec_then `x` assume_tac >> gvs[IN_DEF])
          >> pop_assum $ qspec_then `x` assume_tac >> gvs[IN_DEF])
      >> unabbrev_all_tac
      >> drule EXTREAL_SUP_NEGATIVE_INFINITY_EMPTY_OR_SINGLETON >> strip_tac
      >> gvs[IN_DEF])
  >> Cases_on `sup s = ‚àí‚àû` >> gvs[]
  >> Cases_on `sup t = ‚àí‚àû`
  >- (first_x_assum $ qspecl_then [`t`, `s`] assume_tac
      >> gvs[UNION_COMM])
  >> qpat_x_assum ‚Äò‚àÄa b. _‚Äô kall_tac
  >> Cases_on `sup (s ‚à™ t) = +‚àû`
  >- (drule (iffLR EXTREAL_SUP_POSITIVE_INFINITY) >> strip_tac
      >> drule EXTREAL_SUP_NOT_POSITIVE_INFINITY >> strip_tac
      >> qspec_then `s` assume_tac EXTREAL_SUP_NOT_POSITIVE_INFINITY
      >> rfs[]
      >> last_x_assum $ qspec_then `max x x'` assume_tac
      >> Cases_on `max x x' = +‚àû`
      >- (gvs[extreal_max_def] >> Cases_on `x ‚â§ x'` >> gvs[])
      >> gvs[]
      >> first_x_assum $ qspec_then `y` assume_tac
      >> first_x_assum $ qspec_then `y` assume_tac
      >> gvs[]
      >> gvs[le_max])
  >> Cases_on `sup (s ‚à™ t) = ‚àí‚àû`
  >- (drule (iffLR EXTREAL_SUP_NEGATIVE_INFINITY) >> strip_tac
      >> `sup s = ‚àí‚àû` suffices_by gvs[]
      >> irule (iffRL EXTREAL_SUP_NEGATIVE_INFINITY)
      >> gvs[])
  >> qmatch_goalsub_abbrev_tac `a = max b c`
  >> Cases_on `a` >> gvs[]
  >> Cases_on `b` >> gvs[]
  >> Cases_on ‚Äòc‚Äô >> gvs[]
  >> qspecl_then [`s ‚à™ t`, `r`] assume_tac EXTREAL_SUP_REAL_SUP
  >> qspecl_then [`s`, `r'`] assume_tac EXTREAL_SUP_REAL_SUP
  >> qspecl_then [‚Äòt‚Äô, ‚Äòr''‚Äô] assume_tac EXTREAL_SUP_REAL_SUP
  >> gvs[]
  >> gvs[EXTREAL_MAX_REAL_MAX]
  >> gvs[PREIMAGE_UNION]
  >> irule SUP_UNION
  >> gvs[]
  >> conj_tac
  >- (qexists `sup (PREIMAGE Normal s)`
      >> rpt strip_tac
      >> `Normal x ‚â§ Normal (sup (PREIMAGE Normal s))` suffices_by gvs[]
      >> `Normal x ‚â§ sup s` suffices_by gvs[]
      >> gvs[le_sup_imp'])
  >> conj_tac
  >- (qexists `sup (PREIMAGE Normal t)`
      >> rpt strip_tac
      >> `Normal x ‚â§ Normal (sup (PREIMAGE Normal t))` suffices_by gvs[]
      >> `Normal x ‚â§ sup t` suffices_by gvs[]
      >> gvs[le_sup_imp'])
  >> conj_tac
  >- (qspecl_then [`s`] assume_tac EXTREAL_SUP_NOT_NEGATIVE_INFINITY
      >> gvs[]
      >> qspecl_then [`s`] assume_tac EXTREAL_SUP_NOT_POSITIVE_INFINITY
      >> gvs[]
      >> first_x_assum $ qspec_then `x` assume_tac
      >> gvs[]
      >> `x ‚â† +‚àû` by (CCONTR_TAC >> gvs[le_infty])
      >> Cases_on `x` >> gvs[]
      >> gvs[PREIMAGE_def]
      >> CCONTR_TAC
      >> gvs[]
      >> drule (iffLR EXTENSION) >> strip_tac
      >> pop_assum $ qspec_then `r` assume_tac
      >> gvs[])
  >> qspecl_then [`t`] assume_tac EXTREAL_SUP_NOT_NEGATIVE_INFINITY
  >> gvs[]
  >> qspecl_then [`t`] assume_tac EXTREAL_SUP_NOT_POSITIVE_INFINITY
  >> gvs[]
  >> first_x_assum $ qspec_then `x` assume_tac
  >> gvs[]
  >> `x ‚â† +‚àû` by (CCONTR_TAC >> gvs[le_infty])
  >> Cases_on `x` >> gvs[]
  >> gvs[PREIMAGE_def]
  >> CCONTR_TAC
  >> gvs[]
  >> drule (iffLR EXTENSION) >> strip_tac
  >> pop_assum $ qspec_then `r` assume_tac
  >> gvs[]
QED

Theorem SET_PARTITION:
  ‚àÄs : Œ± -> bool.
    ‚àÄt : Œ± -> bool.
      t ‚äÜ s ‚áí s = t ‚à™ (s DIFF t)
Proof
  rpt strip_tac
  >> gvs[SUBSET_DEF, UNION_DEF, DIFF_DEF]
  >> irule (iffRL EXTENSION)
  >> rpt strip_tac
  >> Cases_on `x ‚àà s` >> gvs[]
  >> CCONTR_TAC
  >> gvs[]
QED

Theorem UNIV_PARTITION:
  ‚àÄs : Œ± -> bool.
    ùïå(:Œ±) = s ‚à™ (ùïå(:Œ±) DIFF s)
Proof
  gvs[SET_PARTITION]
QED

(* SUM_IMAGE_ZERO had forgotten to include a forall statement.
   This version includes the forall statement *)
Theorem SUM_IMAGE_ZERO_FORALL:
  ‚àÄs : Œ± -> bool.
    ‚àÄf : Œ± -> num.
      FINITE s ‚áí
      (‚àë f s = 0n ‚áî ‚àÄx : Œ±. x ‚àà s ‚áí f x = 0n)
Proof
  gvs[SUM_IMAGE_ZERO]
QED

Theorem IMAGE_CONSTANT:
  ‚àÄs : Œ± -> bool.
    ‚àÄc : Œ≤.
      s ‚â† ‚àÖ ‚áí IMAGE (Œªx. c) s = {c}
Proof
  rpt strip_tac
  >> gvs[IMAGE_DEF]
  >> irule (iffRL EXTENSION)
  >> drule CHOICE_DEF >> strip_tac
  >> strip_tac >> gvs[]
  >> Cases_on `x = c` >> gvs[IN_DEF]
  >> qexists `CHOICE s` >> gvs[]
QED

Theorem EXTREAL_SUM_IMAGE_ZERO_ARB_FUNC:
  ‚àÄs : Œ± -> bool.
    ‚àÄf : Œ± -> extreal.
      FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí f x = 0) ‚áí ‚àë f s = 0
Proof
  rpt strip_tac
  >> Induct_on `s` using FINITE_INDUCT
  >> rpt strip_tac >> gvs[]
  >> `‚àë f (e INSERT s) = f e + ‚àë f (s DELETE e)` suffices_by gvs[DELETE_NON_ELEMENT]
  >> qspecl_then [`f`] assume_tac EXTREAL_SUM_IMAGE_THM
  >> gvs[]
  >> pop_assum $ qspecl_then [`e`, `s`] assume_tac
  >> gvs[]
  >> pop_assum irule
  >> disj1_tac
  >> rpt strip_tac
  >> gvs[]
QED

Theorem degenerate_distribution_is_prob_space:
  ‚àÄs : Œ± -> bool.
    ‚àÄx : Œ±.
      x ‚àà s ‚áí
      prob_space (s, POW s, degenerate_distribution x)
Proof
  rpt strip_tac
  >> gvs[degenerate_distribution_def]
  >> gvs[prob_space_def]
  >> gvs[measure_space_def]
  >> conj_tac
  >- gvs[POW_SIGMA_ALGEBRA] (* Proof of sigma algebra *)
  >> conj_tac
  >- (gvs[positive_def] (* Proof of nonnegative measure *)
      >> rpt strip_tac
      >> Cases_on `x ‚àà s'` >> gvs[])
  >> gvs[countably_additive_def]
  >> rpt strip_tac
  >> qmatch_goalsub_abbrev_tac `(if c1 then _ else _) = _`
  >> qmatch_goalsub_abbrev_tac `suminf(g ‚àò f)`
  >> `‚àÄn. 0 ‚â§ (g ‚àò f) n` by (strip_tac >> Cases_on `x ‚àà f n` >> gvs[o_DEF, Abbr `g`])
       >> gvs[ext_suminf_def]
       >> qmatch_goalsub_abbrev_tac `sup (IMAGE h _)`
       >> Cases_on `¬¨c1`
       >- (gvs[Abbr `h`]
           >> sg `‚àÄn. 0 = (g ‚àò f) n`
                   >- (CCONTR_TAC
                       >> gvs[]
                       >> first_x_assum $ qspec_then `f n` assume_tac
                       >> gvs[Abbr `g`]
                       >> pop_assum $ qspec_then `n` assume_tac
                       >> gvs[])
                   >> qmatch_goalsub_abbrev_tac `IMAGE h _`
                   >> sg `h = Œªn.0` >> gvs[Abbr `h`]
                   >- (irule EQ_EXT >> strip_tac >> gvs[]
                       >> irule EXTREAL_SUM_IMAGE_0
                       >> gvs[FINITE_COUNT])
                   >> pop_assum kall_tac
                   >> gvs [IMAGE_CONSTANT]
                   >> gvs[sup_sing])
       >> gvs[]
       >> qmatch_goalsub_abbrev_tac `r = 1`
       >> `1 ‚â§ r ‚àß r ‚â§ 1` suffices_by gvs[iffLR le_antisym]
       >> conj_tac >> gvs[Abbr `r`]
       >- (`1 ‚â§ h (x' + 1)` suffices_by metis_tac[IN_UNIV, le_sup_imp', IMAGE_IN, le_trans]
           >> gvs[Abbr `h`]
           >> gvs[count_add1]
           >> `FINITE (count x')` by gvs[FINITE_COUNT]
           >> qspec_then `g ‚àò f` assume_tac EXTREAL_SUM_IMAGE_THM
           >> gvs[]
           >> pop_assum $ qspecl_then [`x'`, `count x'`] assume_tac
           >> gvs[]
           >> qmatch_asmsub_abbrev_tac `a ‚áí b`
           >> sg `a` >> gvs[Abbr `a`, Abbr `b`]
           >- (disj2_tac >> strip_tac >> strip_tac >> gvs[Abbr `g`] >> Cases_on `x ‚àà f x''` >> gvs[])
           >> (pop_assum kall_tac
               >> qmatch_goalsub_abbrev_tac `_ + q`
               >> qsuff_tac `0 ‚â§ q ‚àß 1 ‚â§ g (f x')`
               >- (strip_tac >> `1 + 0 ‚â§ g (f x') + q` by gvs[le_add2] >> gvs[])
               >> conj_tac
               >- (gvs[Abbr `q`] >> irule EXTREAL_SUM_IMAGE_POS >> gvs[FINITE_COUNT])
               >> gvs[Abbr `g`]))
       >> `‚àÄn. ‚àë (g ‚àò f) (count n) ‚â§ 1` suffices_by
             (rpt strip_tac >> gvs[Abbr `h`]
              >> irule (iffRL sup_le')
              >> rpt strip_tac >> gvs[])
            >> strip_tac
            >> `‚àÄx'' : num. x'' ‚â† x' ‚áí x ‚àâ f x''` by
                       (rpt strip_tac
                        >> last_x_assum $ qspecl_then [`x'`, `x''`] assume_tac
                        >> gvs[]
                        >> qspecl_then [`f x'`, `f x''`, `x`] assume_tac DISJOINT_IN
                        >> gvs[])
                 >> sg `‚àë (g ‚àò f) (count n) = ‚àë (g ‚àò f) ((count n) DIFF {x'}) + if n > x' then (g ‚àò f) x' else 0`
                 >- (Cases_on `n > x'` >> gvs[Abbr `h`]
                     >- (sg `count n = (count n DIFF {x'}) ‚à™ {x'}`
                         >- (gvs[]
                             >> `x' ‚àà count n` by gvs[]
                             >> irule $ iffRL EXTENSION
                             >> gvs[])
                         >> pop_assum (fn th => PURE_REWRITE_TAC [Once th])
                         >> `g (f x') = ‚àë (g ‚àò f) {x'}` by gvs[]
                         >> pop_assum (fn th => PURE_REWRITE_TAC [Once th])
                         >> irule EXTREAL_SUM_IMAGE_DISJOINT_UNION
                         >> gvs[FINITE_COUNT, FINITE_DIFF, DISJOINT_DIFF]
                         >> disj1_tac
                         >> rpt strip_tac
                         >> (first_assum $ qspec_then `x''` assume_tac >> gvs[Abbr `g`]))
                     >> `n ‚â§ x'` by gvs[] >> gvs[]
                     >> `count n DIFF {x'} = count n` suffices_by gvs[]
                     >> `x' ‚àâ count n` by gvs[]
                     >> gvs[DELETE_NON_ELEMENT, DELETE_DEF])
                 >> gvs[]
                 >> pop_assum kall_tac
                 >> qsuff_tac `‚àë (g ‚àò f) (count n DIFF {x'}) = 0`
                 >- (strip_tac >> gvs[]
                     >> gvs[Abbr `g`] >> Cases_on `n > x'` >> gvs[])
                 >> irule EXTREAL_SUM_IMAGE_ZERO_ARB_FUNC
                 >> conj_tac
                 >- (rpt strip_tac
                         >>`x'' ‚â† x'` by gvs[]
                     >> first_x_assum drule >> strip_tac
                     >> gvs[Abbr `g`])
                 >> gvs[FINITE_COUNT]
QED

Theorem length_n_codes_degenerate_prob_space_is_prob_space:
  ‚àÄn : num. ‚àÄbs : bool list.
              bs ‚àà length_n_codes n ‚áí
              prob_space (length_n_codes_degenerate_prob_space n bs)
Proof
  gvs[length_n_codes_degenerate_prob_space_def, degenerate_distribution_is_prob_space]
QED

(* -------------------------------------------------------------------------- *)
(* Takes bs, an initial bitstring, and ns, a list of booleans that describe   *)
(* whether or not to apply noise at each position, and returns the bitstring  *)
(* which has had noise applied in each of the appropriate positions           *)
(* -------------------------------------------------------------------------- *)
Definition apply_noise_def:
  apply_noise = bxor
End

Definition num_errors_def:
  num_errors (ns : bool list) = LENGTH (FILTER (Œªx.x) ns)
End

Theorem le_not_posinf:
  ‚àÄx y : extreal. x ‚â§ y ‚àß y ‚â† +‚àû ‚áí x ‚â† +‚àû
Proof
  rpt strip_tac >> gvs[]
  >> Cases_on ‚Äòy‚Äô >> gvs[]
QED

Theorem le_not_neginf:
  ‚àÄx y : extreal. y ‚â§ x ‚àß y ‚â† ‚àí‚àû ‚áí x ‚â† ‚àí‚àû
Proof
  rpt strip_tac >> gvs[]
  >> Cases_on ‚Äòy‚Äô >> gvs[]
QED

(* It doesn't seem to me that countably_additive should be dependent on the
   measure being nonnegative everywhere, but it is, because it depends on
   suminf, which has the condition of nonnegativity everywhere. I'm not
   convinced that suminf needs the condition of nonnegativity everywhere,
   but under the current definition of suminf, which uses a supremum instead
   of a limit, it is necessary to ensure that the infinite sum has the right
   value. Ideally it would use the limit definition of an infinite sum instead,
   so that it can handle negative values.
   -------------
   
   We discussed this issue. It seems to not be such a big problem since
   a measure is always supposed to be nonnegative everywhere. Using the
   alternative definition, we would have to constantly check that the sum
   converges, which may be more of a nuisance. Using the current version of
   suminf, we can be sure that the sum converges to some value (possibly
   infinity), by the monotone convergence theorem, and the fact that the
   sum applied to positive values is monotone.

   Still, under certain circumstances, maybe it'll be useful to discuss
   countably additive functions which are not strictly positive?
 *)

Theorem INSERT_UNION_EQ2:
  ‚àÄx : Œ±.
    ‚àÄs t : Œ± -> bool.
      s ‚à™ (x INSERT t) = x INSERT (s ‚à™ t)
Proof
  rpt strip_tac
  >> metis_tac[UNION_COMM, INSERT_UNION_EQ]
QED

(*Theorem extreal_sum_image_union:
  ‚àÄf : Œ± -> extreal.
    ‚àÄ g h : Œ≤ -> Œ±.
      ‚àÄs : Œ≤ -> bool.
        FINITE s ‚àß
        DISJOINT (IMAGE g s) (IMAGE h s) ‚àß
        ((‚àÄx. x ‚àà IMAGE g s ‚à™ IMAGE h s ‚áí f x ‚â† +‚àû) ‚à® (‚àÄx. x ‚àà IMAGE g s ‚à™ IMAGE h s ‚áí f x ‚â† ‚àí‚àû)) ‚áí
        ‚àë f ((IMAGE g s) ‚à™ (IMAGE h s)) = ‚àë (Œªbs. (f ‚àò g) bs + (f ‚àò h) bs) s
Proof
  rpt gen_tac
  >> disch_tac >> rpt (pop_assum $ CONJUNCTS_THEN assume_tac)
  >> Induct_on ‚Äòs‚Äô
  >> gvs[]
  >> rpt (rpt gen_tac >> disch_tac)
  >> fs[]
  >> first_x_assum $ CONJUNCTS_THEN assume_tac
  >> gvs[INSERT_UNION_EQ, INSERT_UNION_EQ2]
  >> qspec_then ‚Äòf‚Äô assume_tac EXTREAL_SUM_IMAGE_THM
  >> gvs[]
  >> qmatch_goalsub_abbrev_tac ‚Äò‚àë f (g e INSERT t)‚Äô
  >> first_assum $ qspecl_then [‚Äòg e‚Äô, ‚Äòt‚Äô] assume_tac
  >> qmatch_asmsub_abbrev_tac ‚Äòpremises ‚áí goal‚Äô
  >> sg ‚Äògoal‚Äô
  >- (first_x_assum irule
      >> gvs[Abbr ‚Äòpremises‚Äô]
      >> conj_tac
      >- gvs[Abbr ‚Äòt‚Äô]
      >> disj2_tac
      >> gen_tac
      >> disch_tac
QED*)

(*Theorem extreal_sum_length_n_codes_suc:
  ‚àÄf : bool list -> extreal.
    ‚àÄn : num.
      (‚àÄcs. cs ‚àà (length_n_codes (SUC n)) ‚áí f cs ‚â† ‚àí‚àû) ‚à® (‚àÄcs. cs ‚àà (length_n_codes (SUC n)) ‚áí f cs ‚â† +‚àû) ‚áí
      ‚àë f (length_n_codes (SUC n)) = ‚àë (Œªbs : bool list. ‚àë f {T::bs; F::bs}) (length_n_codes n)
Proof
  rpt gen_tac
  >> DISCH_TAC
  >> simp[length_n_codes_suc]
  >> qmatch_goalsub_abbrev_tac ‚Äòu1 ‚à™ u2‚Äô
  >>

  
  >> sg ‚Äò‚àë f (u1 ‚à™ u2) = ‚àë f u1 + ‚àë f u2‚Äô
  >- (irule EXTREAL_SUM_IMAGE_DISJOINT_UNION
      >> conj_tac
      >- gvs[IMAGE_FINITE, length_n_codes_finite, Abbr ‚Äòu1‚Äô, Abbr ‚Äòu2‚Äô]
      >> conj_tac
      >- gvs[IMAGE_FINITE, length_n_codes_finite, Abbr ‚Äòu1‚Äô, Abbr ‚Äòu2‚Äô]
      >> conj_tac
      >- (simp[DISJOINT_DEF, INTER_DEF]
          >> irule $ iffRL EXTENSION
          >> strip_tac
          >> Cases_on ‚Äòx ‚àà ‚àÖ‚Äô
          >- gvs[]
          >> simp[]
          >> Cases_on ‚Äòx‚Äô
          >- (unabbrev_all_tac >> gvs[IMAGE_DEF, length_n_codes_def])
          >> Cases_on ‚Äòh‚Äô >> unabbrev_all_tac >> gvs[IMAGE_DEF, length_n_codes_def])
      >> gvs[]
      >- (disj1_tac
          >> gen_tac >> DISCH_TAC
          >> last_x_assum irule
          >> gvs[Abbr ‚Äòu1‚Äô, Abbr ‚Äòu2‚Äô, IMAGE_DEF, length_n_codes_def])
      >> disj2_tac
      >> gen_tac >> DISCH_TAC
      >> last_x_assum irule
      >> gvs[Abbr ‚Äòu1‚Äô, Abbr ‚Äòu2‚Äô, IMAGE_DEF, length_n_codes_def])
  >> pop_assum $ (fn th => PURE_REWRITE_TAC [th])
  >> ‚àë (Œªx. ‚àë f x) 

       unabbrev_all_tac
  >> 

  ‚àë (f : Œ± -> extreal) _ + ‚àë f _
QED*)

Theorem num_errors_length:
  ‚àÄx. num_errors x ‚â§ LENGTH x
Proof
  rpt strip_tac
  >> gvs[num_errors_def]
  >> gvs[LENGTH_FILTER_LEQ]
QED

Theorem sym_noise_dist_empty:
  ‚àÄp.
    sym_noise_dist p ‚àÖ = 0
Proof
  gvs[sym_noise_dist_def]
QED

(* -------------------------------------------------------------------------- *)
(* Takes an input probability distribution and returns the output probability *)
(* distribution with errors randomly added                                    *)
(* ---                                                                        *)
(* Note: there was an error in the way this was defined, but it turns out to  *)
(* be equivalent and provides a simpler definition, so I kept it that way.    *)
(*                                                                            *)
(* Given an original bitstring bs, the probability of a given output          *)
(* bitstring should be calculated as the probability of choosing a noise      *)
(* bitstring such that applying the noise bitstring to the original bistring  *)
(* results in the output bitstring.                                           *)
(*                                                                            *)
(* This function instead treats the output bitstring as noise (which it isn't)*)
(* , then it applies it as noise to the original bitstring, and checks what   *)
(* the probability of the resulting bitstring being chosen as noise is.       *)
(*                                                                            *)
(* However, this is equivalent, because there is exactly one choice of noise  *)
(* that, when applied to the original bitstring, returns the output bitstring,*)
(* and this choice of noise is precisely that obtained by applying the output *)
(* bitstring to the original bitstring. This follows from the fact that       *)
(* apply_noise is its own inverse, and so if we let bs denote the original    *)
(* bitstring and we let cs denote the output bitstring, we have               *)
(* apply_noise bs (apply_noise bs cs) = cs, and so the unique choice of noise *)
(* returning the output bitstring is when applied to the original bistring is *)
(* precisely that which is obtained by applying the original bitstring to the *)
(* output bitstring.                                                          *)
(*                                                                            *)
(* The equivalence of these definitions is formally proven in                 *)
(* sym_err_chan_prob_space_apply_noise_distribution, which proves that        *)
(* sym_err_chan_prob_space is the resulting distribution when applying noise  *)
(* derived from the distribution sym_noise_dist to a certain bitstring        *)
(* -------------------------------------------------------------------------- *)
Definition sym_err_chan_mass_func_def:
  sym_err_chan_mass_func (p : extreal) (bs : bool list) = (sym_noise_mass_func p) ‚àò (apply_noise bs)
End

Definition sym_err_chan_dist_def:
  sym_err_chan_dist p bs = ‚àë (sym_err_chan_mass_func p bs)
End

Definition sym_err_chan_prob_space_def:
  sym_err_chan_prob_space n p bs =
  (length_n_codes n, POW (length_n_codes n), sym_err_chan_dist p bs)
End

(* Provide a nicer interpretation of bitwise than its original definition *)
Theorem bitwise_el:
  ‚àÄf bs cs x.
    LENGTH bs = LENGTH cs ‚àß x < LENGTH bs ‚áí
    ((EL x (bitwise f bs cs)) ‚áî f (EL x bs) (EL x cs))
Proof
  rpt strip_tac
  >> gvs[bitwise_def, EL_MAP, EL_ZIP]
QED

Theorem bitwise_length:
  ‚àÄf bs cs.
    LENGTH (bitwise f bs cs) = MAX (LENGTH bs) (LENGTH cs)
Proof
  simp[bitwise_def]
QED

Theorem bitwise_eq:
  ‚àÄf bs cs ds.
    LENGTH bs = LENGTH cs ‚àß LENGTH cs = LENGTH ds ‚áí
    (bitwise f bs cs = ds ‚áî (‚àÄx. x < LENGTH bs ‚áí f (EL x bs) (EL x cs) = EL x ds))
Proof
  rpt strip_tac
  >> EQ_TAC >> rpt strip_tac >> gvs[]
  >- (irule EQ_SYM
      >> irule bitwise_el
      >> gvs[])
  >> irule $ iffRL LIST_EQ_REWRITE
  >> REVERSE conj_tac
  >> gvs[bitwise_length]
  >> rpt strip_tac
  >> first_x_assum $ qspec_then ‚Äòx‚Äô (fn th => gvs[GSYM th])
  >> irule bitwise_el
  >> gvs[]
QED

Theorem NOT_IFF_INV:
  ‚àÄ b c.
    (b ‚áé (b ‚áé c)) ‚áî c
Proof
  rpt strip_tac
  >> Cases_on ‚Äòb‚Äô >> gvs[]
QED

Theorem bxor_inv:
  ‚àÄbs cs.
    LENGTH bs = LENGTH cs ‚áí
    bxor bs (bxor bs cs) = cs
Proof
  rpt strip_tac
  >> gvs[bxor_def]
  >> irule $ iffRL bitwise_eq
  >> gvs[bitwise_length]
  >> rpt strip_tac
  >> DEP_PURE_ONCE_REWRITE_TAC [bitwise_el]
  >> gvs[NOT_IFF_INV]
QED

Theorem bxor_length:
  ‚àÄbs cs.
    LENGTH (bxor bs cs) = MAX (LENGTH bs) (LENGTH cs)
Proof
  simp[bxor_def, bitwise_length]
QED

Theorem bxor_inj:
  ‚àÄbs. INJ (bxor bs) (length_n_codes (LENGTH bs)) (length_n_codes (LENGTH bs))
Proof
  rpt strip_tac
  >> gvs[INJ_DEF]
  >> rpt strip_tac
  >- gvs[bxor_length]
  >> qspecl_then [‚Äòbs‚Äô, ‚Äòx‚Äô] assume_tac bxor_inv
  >> qspecl_then [‚Äòbs‚Äô, ‚Äòy‚Äô] assume_tac bxor_inv
  >> gvs[]
QED

Theorem apply_noise_inj:
  ‚àÄbs.
    INJ (apply_noise bs) (length_n_codes (LENGTH bs)) (length_n_codes (LENGTH bs))
Proof
  gvs[apply_noise_def, bxor_inj]
QED

Theorem apply_noise_inv:
  ‚àÄbs cs.
    LENGTH bs = LENGTH cs ‚áí
    apply_noise bs (apply_noise bs cs) = cs
Proof
  gvs[apply_noise_def, bxor_inv]
QED

(* -------------------------------------------------------------------------- *)
(* This theorem became broken as a result of the removal of n from the        *)
(* distribution and mass functions, and it's not important enough to fix      *)
(* -------------------------------------------------------------------------- *)
(*
Theorem sym_err_chan_dist_sym_noise_dist:
  ‚àÄn p bs s.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚àß bs ‚àà length_n_codes n ‚àß s ‚äÜ length_n_codes n ‚áí
    sym_err_chan_dist n p bs s = sym_noise_dist n p (IMAGE (apply_noise bs) s)
Proof
  rpt strip_tac
  >> gvs[sym_err_chan_dist_def, sym_err_chan_mass_func_def, sym_noise_dist_def]
  >> irule $ GSYM EXTREAL_SUM_IMAGE_IMAGE
  >> conj_tac
  >- metis_tac[SUBSET_FINITE, length_n_codes_finite]
  >> gvs[]
  >> rpt strip_tac
  >- (disj1_tac >> gvs[sym_noise_mass_func_not_neginf])
  >> irule INJ_IMAGE
  >> qexists ‚Äòlength_n_codes n‚Äô
  >> irule INJ_SUBSET
  >> qexistsl [‚Äòlength_n_codes n‚Äô, ‚Äòlength_n_codes n‚Äô]
  >> gvs[apply_noise_inj]
QED
*)

Theorem apply_noise_length:
  ‚àÄn bs cs.
    LENGTH (apply_noise bs cs) = MAX (LENGTH bs) (LENGTH cs)
Proof
  rpt strip_tac
  >> gvs[apply_noise_def, bxor_length]
QED

Theorem apply_noise_length_n_codes:
  ‚àÄn bs cs.
    bs ‚àà length_n_codes n ‚àß cs ‚àà length_n_codes n ‚áí
    apply_noise bs cs ‚àà length_n_codes n
Proof
  simp[apply_noise_length]
QED

Theorem apply_noise_image_length_n_codes:
  ‚àÄn bs s.
    bs ‚àà length_n_codes n ‚àß s ‚äÜ length_n_codes n ‚áí
    IMAGE (apply_noise bs) s ‚äÜ length_n_codes n
Proof
  rpt strip_tac
  >> gvs[IMAGE_DEF]
  >> gvs[SUBSET_DEF]
  >> rpt strip_tac
  >> gvs[apply_noise_length_n_codes, apply_noise_length]
QED

Theorem apply_noise_random_variable:
  ‚àÄn p bs.
    LENGTH bs = n ‚áí
    random_variable (apply_noise bs) (sym_noise_prob_space n p) (measurable_space (sym_err_chan_prob_space n p bs))
Proof
  rpt strip_tac
  >> gvs[random_variable_def]
  >> gvs[measurable_def]
  >> gvs[IN_DEF]
  >> rpt strip_tac
  >- gvs[sym_noise_prob_space_def, sym_err_chan_prob_space_def, p_space_def, apply_noise_length]
  >> gvs[sym_noise_prob_space_def, sym_err_chan_prob_space_def, events_def, p_space_def]
QED

Theorem apply_noise_preimage_length_n_codes:
  ‚àÄn bs s.
    LENGTH bs = n ‚àß s ‚äÜ length_n_codes n ‚áí
    (PREIMAGE (apply_noise bs) s) ‚à© length_n_codes n = IMAGE (apply_noise bs) s
Proof
  rpt strip_tac
  >> irule $ iffRL EXTENSION
  >> rpt strip_tac
  >> EQ_TAC >> strip_tac
  >- (gvs[PREIMAGE_def]
      >> qexists ‚Äòapply_noise bs x‚Äô
      >> gvs[]
      >> DEP_PURE_REWRITE_TAC[apply_noise_inv]
      >> gvs[])
  >> gvs[PREIMAGE_def]
  >> conj_tac
  >- (DEP_PURE_REWRITE_TAC[apply_noise_inv]
      >> gvs[SUBSET_DEF])
  >> gvs[SUBSET_DEF]
  >> last_x_assum $ qspec_then ‚Äòx'‚Äô assume_tac
  >> gvs[]
  >> DEP_PURE_REWRITE_TAC[apply_noise_length_n_codes]
  >> gvs[apply_noise_length]
QED

(* -------------------------------------------------------------------------- *)
(* This theorem became broken as a result of the removal of n from the        *)
(* distribution and mass functions, and it's not important enough to fix      *)
(* -------------------------------------------------------------------------- *)
(*Theorem sym_err_chan_prob_space_apply_noise_distribution:
  ‚àÄn p bs s.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚àß LENGTH bs = n ‚àß s ‚äÜ length_n_codes n ‚áí
    distribution (sym_noise_prob_space n p) (apply_noise bs) s =
    sym_err_chan_dist p bs s
Proof
  rpt strip_tac
  >> gs[distribution_def, sym_noise_prob_space_def, prob_def, p_space_def]
  >> DEP_PURE_REWRITE_TAC[sym_err_chan_dist_sym_noise_dist]
  >> gs[]
  >> conj_tac >- gs[]
  >> AP_TERM_TAC
  >> gvs[apply_noise_preimage_length_n_codes]
QED*)

(* measure_preserving *)
(* distribution_def
   distr_def
   measure_space_distr
   distribution_prob_space
 *)

Theorem algebra_space_in_subsets:
  ‚àÄa. algebra a ‚áí space a ‚àà subsets a
Proof
  rpt strip_tac
  >> gvs[algebra_def]
  >> last_x_assum $ qspec_then ‚Äò‚àÖ‚Äô assume_tac
  >> gvs[]
QED

Theorem measure_space_is_measurable:
  ‚àÄs a p.
    measure_space (s, a, p) ‚áí s ‚àà a
Proof
  rpt strip_tac
  >> gvs[measure_space_def, sigma_algebra_def]
  >> drule algebra_space_in_subsets
  >> gvs[]
QED

Theorem sample_space_is_event:
  ‚àÄs a p.
    prob_space (s, a, p) ‚áí s ‚àà a
Proof
  rpt strip_tac
  >> drule EVENTS_ALGEBRA >> strip_tac
  >> gvs[p_space_def, events_def]
  >> drule algebra_space_in_subsets
  >> gvs[]
QED

(* similar in spirit to measure_space_cong *)
Theorem prob_space_cong:
  ‚àÄs a p1 p2.
    (‚àÄx. x ‚àà a ‚áí p1 x = p2 x) ‚áí
    (prob_space (s, a, p1) ‚áî prob_space (s, a, p2))
Proof
  rpt strip_tac
  >> gvs[prob_space_def]
  >> irule AND_CONG
  >> conj_tac
  >- (disch_tac
      >> first_x_assum $ qspec_then ‚Äòs‚Äô assume_tac
      >> drule measure_space_is_measurable
      >> gvs[])
  >> disch_tac
  >> irule measure_space_cong
  >> gvs[]
QED

(* -------------------------------------------------------------------------- *)
(* This theorem became broken as a result of the removal of n from the        *)
(* distribution and mass functions, and it's not important enough to fix      *)
(* -------------------------------------------------------------------------- *)
(*
Theorem sym_err_chan_prob_space_is_prob_space:
  ‚àÄn p bs.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚àß
    bs ‚àà length_n_codes n ‚áí
    prob_space (sym_err_chan_prob_space n p bs)
Proof
  rpt strip_tac
  >> gvs[sym_err_chan_prob_space_def]
  >> qmatch_goalsub_abbrev_tac ‚Äòprob_space (s, a, p1)‚Äô
  >> qspecl_then [‚Äòs‚Äô, ‚Äòa‚Äô, ‚Äòp1‚Äô, ‚Äòdistribution (sym_noise_prob_space n p) (apply_noise bs)‚Äô] assume_tac prob_space_cong
  >> pop_assum $ (fn th => DEP_PURE_REWRITE_TAC [th])
  >> rpt strip_tac
  >- (unabbrev_all_tac
      >> irule $ GSYM sym_err_chan_prob_space_apply_noise_distribution
      >> gvs[POW_DEF])
  >> gvs[Abbr ‚Äòp1‚Äô]
  >> qspecl_then [‚Äòsym_noise_prob_space n p‚Äô, ‚Äòapply_noise bs‚Äô, ‚Äòmeasurable_space (sym_err_chan_prob_space n p bs)‚Äô] assume_tac distribution_prob_space
  >> gvs[sym_err_chan_prob_space_def]
  >> pop_assum irule
  >> conj_tac
  >- gvs[sym_noise_prob_space_is_prob_space]
  >> conj_tac
  >- (unabbrev_all_tac >> gvs[POW_SIGMA_ALGEBRA])
  >> unabbrev_all_tac
  >> gs[]
  >> drule apply_noise_random_variable
  >> rpt strip_tac
  >> gvs[sym_err_chan_prob_space_def]
QED*)

(* ----------------------------------------------- *)

Definition n_repetition_bit_def[simp]:
  n_repetition_bit 0 b = [] ‚àß
  n_repetition_bit (SUC n) b = b::(n_repetition_bit n b)
End

Definition n_repetition_code_def[simp]:
  n_repetition_code n [] = [] ‚àß
  n_repetition_code n (b::bs) = (n_repetition_bit n b) ‚ß∫ (n_repetition_code n bs)
End

Definition is_decoded_nearest_neighbour_def:
  is_decoded_nearest_neighbour n code_fn bs cs =
  (cs ‚àà length_n_codes n ‚àß
   ‚àÄds. ds ‚àà length_n_codes n ‚áí
        hamming_distance bs (code_fn cs) ‚â§ hamming_distance bs (code_fn ds))
End

(* What if there are multiple nearest neighbours? *)
Definition decode_nearest_neighbour_def:
  decode_nearest_neighbour n code_fn bs =
  @cs. is_decoded_nearest_neighbour n code_fn bs cs
End

Definition n_repetition_bit_inverse_def:
  (n_repetition_bit_inverse (nT : num) (nF : num) ([] : bool list) = if nT ‚â§ nF then F else T) ‚àß
  n_repetition_bit_inverse nT nF (T::bs) = n_repetition_bit_inverse (nT + 1) nF bs ‚àß 
  n_repetition_bit_inverse nT nF (F::bs) = n_repetition_bit_inverse nT (nF + 1) bs
End

(* -------------------------------------------------------------------------- *)
(* This became broken, possibly because WF_IMAGE may have been moved from the *)
(* place where it was previously, but it isn't important enough to fix.       *)
(* -------------------------------------------------------------------------- *)
(*Definition n_repetition_code_inverse_def:
  n_repetition_code_inverse n ([] : bool list) = [] ‚àß
  n_repetition_code_inverse 0 bs = [] ‚àß
  n_repetition_code_inverse (SUC n) bs = (n_repetition_bit_inverse 0 0 (TAKE (SUC n) bs))::(n_repetition_code_inverse (SUC n) (DROP (SUC n) bs))
Termination
  qexists ‚Äò(Œªbs cs. (LENGTH (SND bs) < LENGTH (SND cs)))‚Äô
  >> conj_tac
  >- (qspecl_then [‚Äò$< : num -> num -> bool‚Äô, ‚Äò(LENGTH ‚àò SND) : num # bool list -> num‚Äô] assume_tac WF_IMAGE >> gvs[WF_num])
  >> rpt strip_tac
  >> gvs[]
End*)

Definition q2_sym_prob_space_def:
  q2_sym_prob_space p = ((length_n_codes_uniform_prob_space 1) √ó (sym_noise_prob_space 3 p))
End

(* Check that after encoding a bitstring, applying a specific choice of
   noise, and then decoding the bitstring, we get the correct result *)
Definition code_decodes_correctly_def:
  code_decodes_correctly (n : num) (bs : bool list) (ns : bool list) (code_fn : bool list -> bool list) : bool
  = ((decode_nearest_neighbour n code_fn (apply_noise ns (code_fn bs))) = bs)
End

Definition q2_sym_prob_correctly_decoded_def:
  q2_sym_prob_correctly_decoded p = (measure (q2_sym_prob_space p)) {(bs, ns) | bs ‚àà length_n_codes 1 ‚àß ns ‚àà length_n_codes 3 ‚àß (code_decodes_correctly 1 bs ns (n_repetition_code 3))} 
End

(*Definition q2_asym_prob_space_def:
  q2_asym_prob_space p = ((length_n_codes_uniform_prob_space 1) √ó ()
                          End*)

(*Definition q2_asym_prob_correctly_decoded_def:
  q2_asym_prob_correctly_decoded p = (measure ()) {}
End*)

Theorem SELECT_WEAKEN_CONDITION:
  ‚àÄP Q. (‚àÉx. P x) ‚àß (‚àÄx. P x ‚áí Q x) ‚áí Q (@x. P x)
Proof
  rpt strip_tac
  >> pop_assum irule
  >> irule (iffRL SELECT_THM)
  >> qexists ‚Äòx‚Äô
  >> gvs[]      
QED

Theorem hamming_distance_append[simp]:
  ‚àÄbs cs ds es.
    LENGTH bs = LENGTH ds ‚áí
    hamming_distance (bs ‚ß∫ cs) (ds ‚ß∫ es) = hamming_distance bs ds + hamming_distance cs es
Proof
  strip_tac
  >> Induct_on ‚Äòbs‚Äô >> rpt strip_tac
  >- gvs[hamming_distance_def]
  >> Cases_on ‚Äòds‚Äô >> gvs[]
  >> gvs[hamming_distance_cons]
QED

Theorem n_repetition_bit_hamming_distance[simp]:
  ‚àÄb b' n.
    hamming_distance (n_repetition_bit n b) (n_repetition_bit n b') = if b = b' then 0 else n
Proof
  rpt strip_tac
  >> Induct_on ‚Äòn‚Äô
  >- gvs[n_repetition_bit_def, hamming_distance_def]
  >> Cases_on ‚Äòb = b'‚Äô >> gvs[]
QED

Theorem n_repetition_bit_length[simp]:
  ‚àÄn b. LENGTH (n_repetition_bit n b) = n
Proof
  rpt strip_tac
  >> Induct_on ‚Äòn‚Äô >> gvs[n_repetition_bit_def]
QED

Theorem n_repetition_code_hamming_distance[simp]:
  ‚àÄbs cs n.
    LENGTH bs = LENGTH cs ‚áí
    hamming_distance (n_repetition_code n bs) (n_repetition_code n cs) = n * hamming_distance bs cs
Proof
  strip_tac
  >> Induct_on ‚Äòbs‚Äô >> Cases_on ‚Äòcs‚Äô >> gvs[]
  >> rpt strip_tac
  >> last_x_assum $ qspecl_then [‚Äòt‚Äô, ‚Äòn‚Äô] assume_tac
  >> gvs[]
  >> Cases_on ‚Äòh' = h‚Äô >> gvs[]
QED

Theorem n_repetition_code_hamming_distance':
  ‚àÄbs cs n.
    LENGTH bs = LENGTH cs ‚àß
    hamming_distance (n_repetition_code n bs) (n_repetition_code n cs) < n ‚áí
    bs = cs
Proof
  gen_tac
  >> Induct_on ‚Äòbs‚Äô >> rpt strip_tac
  >- (Cases_on ‚Äòcs‚Äô >> gvs[])
  >> Cases_on ‚Äòcs‚Äô >> gvs[]
  >> gvs[n_repetition_code_def]
  >> last_x_assum $ qspecl_then [‚Äòt‚Äô, ‚Äòn‚Äô] assume_tac
  >> gvs[]
  >> Cases_on ‚Äòh = h'‚Äô >> gvs[]
QED

(* -------------------------------------------------------------------------- *)
(* This became broken, possibly because WF_IMAGE may have been moved from the *)
(* place where it was previously, but it isn't important enough to fix.       *)
(* -------------------------------------------------------------------------- *)
(*
Theorem exists_decode_nearest_neighbour_candidate:
  ‚àÄn code_fn bs.
    ‚àÉds. is_decoded_nearest_neighbour n code_fn bs ds
Proof
  rpt strip_tac
  >> gvs[is_decoded_nearest_neighbour_def]
  >> sg ‚Äòlet f n = (Œªn. hamming_distance bs (code_fn n)) n in WF (Œªx y. f x < f y)‚Äô
  >- (PURE_REWRITE_TAC[Once LET_THM]
      >> CONV_TAC BETA_CONV
      >> irule WF_IMAGE
      >> gvs[WF_LESS])
  >> gvs[WF_DEF]
  >> pop_assum $ qspec_then ‚Äòlength_n_codes n‚Äô assume_tac
  >> qmatch_asmsub_abbrev_tac ‚Äòprem ‚áí concl‚Äô
  >> sg ‚Äòprem‚Äô
  >- (unabbrev_all_tac
      >> qexists ‚Äòn_repetition_bit n T‚Äô
      >> gvs[n_repetition_bit_length])
  >> gvs[]
  >> qexists ‚Äòy‚Äô >> gvs[IN_DEF]
  >> rpt strip_tac
  >> first_x_assum $ qspec_then ‚Äòds‚Äô assume_tac
  >> gvs[]
QED
*)

Theorem n_repetition_code_0[simp]:
  ‚àÄbs.
    n_repetition_code 0 bs = []
Proof
  Induct_on ‚Äòbs‚Äô >> gvs[n_repetition_code_def, n_repetition_bit_def]
QED

Theorem n_repetition_code_divides:
  ‚àÄbs cs n.
    LENGTH bs = LENGTH cs ‚áí
    divides n (hamming_distance (n_repetition_code n bs) (n_repetition_code n cs))
Proof
  strip_tac
  >> Induct_on ‚Äòbs‚Äô >> rpt strip_tac
  >- (Cases_on ‚Äòcs‚Äô >> gvs[n_repetition_code_def])
  >> Cases_on ‚Äòcs‚Äô >> gvs[]
  >> last_x_assum $ qspecl_then [‚Äòt‚Äô, ‚Äòn‚Äô] assume_tac
  >> gvs[n_repetition_code_def, hamming_distance_cons]
  >> DEP_PURE_ONCE_REWRITE_TAC[hamming_distance_append]
  >> gvs[n_repetition_bit_length]
  >> irule DIVIDES_ADD_1 >> gvs[]
  >> pop_assum kall_tac
  >> gvs[n_repetition_bit_hamming_distance]
  >> Cases_on ‚Äòh = h'‚Äô >> gvs[]
QED

Theorem hamming_distance_positivity:
  ‚àÄbs cs.
    LENGTH bs = LENGTH cs ‚áí
    0 ‚â§ hamming_distance bs cs ‚àß
    (hamming_distance bs cs = 0 ‚áî bs = cs)
Proof
  rpt strip_tac
  >- gvs[hamming_distance_def]
  >> ‚Äò‚àÄcs. LENGTH bs = LENGTH cs ‚áí (hamming_distance bs cs = 0 ‚áî bs = cs)‚Äô suffices_by gvs[]
  >> pop_assum kall_tac
  >> Induct_on ‚Äòbs‚Äô >> rpt strip_tac >> Cases_on ‚Äòcs‚Äô >> gvs[]
  >> EQ_TAC >> rpt strip_tac >> gvs[]
  >> Cases_on ‚Äòh = h'‚Äô >> gvs[]
QED

Theorem hamming_distance_sym:
  ‚àÄbs cs.
    LENGTH bs = LENGTH cs ‚áí
    hamming_distance bs cs = hamming_distance cs bs
Proof
  strip_tac
  >> Induct_on ‚Äòbs‚Äô >> Cases_on ‚Äòcs‚Äô >> gvs[]
  >> rpt strip_tac
  >> first_x_assum $ qspec_then ‚Äòt‚Äô assume_tac
  >> Cases_on ‚Äòh = h'‚Äô >> gvs[EQ_SYM]
QED

Theorem hamming_distance_same[simp]:
  ‚àÄbs. hamming_distance bs bs = 0
Proof
  rpt strip_tac
  >> assume_tac hamming_distance_positivity
  >> pop_assum $ qspecl_then [‚Äòbs‚Äô, ‚Äòbs‚Äô] assume_tac
  >> gvs[]
QED

(* -------------------------------------------------------------------------- *)
(* Initially I thought that the hamming distance between two points precisely *)
(* satisfied the triangle equality if and only if the middle point was one    *)
(* of the endpoints, but this is not necessarily the case.                    *)
(*                                                                            *)
(* hamming (0, 1) (1, 0) = 2                                                  *)
(* hamming (0, 1) (0, 0) + hamming (0, 0) (1, 0) = 1 + 1 = 2                  *)
(* -------------------------------------------------------------------------- *)
Theorem hamming_distance_triangle_inequality:
  ‚àÄbs cs ds.
    (LENGTH bs = LENGTH cs ‚àß LENGTH cs = LENGTH ds) ‚áí
    hamming_distance bs ds ‚â§ hamming_distance bs cs + hamming_distance cs ds
Proof
  rpt strip_tac
  >> ‚Äò‚àÄbs ds. LENGTH bs = LENGTH cs ‚àß LENGTH cs = LENGTH ds ‚áí hamming_distance bs ds ‚â§ hamming_distance bs cs + hamming_distance cs ds‚Äô suffices_by gvs[]
  >> rpt $ pop_assum kall_tac
  >> Induct_on ‚Äòcs‚Äô >> rpt strip_tac >> Cases_on ‚Äòbs‚Äô >> Cases_on ‚Äòds‚Äô >> gvs[]
  >> first_x_assum $ qspecl_then [‚Äòt‚Äô, ‚Äòt'‚Äô] assume_tac
  >> Cases_on ‚Äòh = h''‚Äô >> Cases_on ‚Äòh' = h‚Äô >> Cases_on ‚Äòh' = h''‚Äô >> gvs[]
QED

(* MODEQ_REFL has two issues: firstly, it isn't in the simpset, when it would
   make sense for it to be. Secondly, the variable n isn't bound by a
   quantifier. *)
Theorem MODEQ_REFL'[simp]:
  ‚àÄn x. MODEQ n x x
Proof
  gvs[MODEQ_REFL]
QED

(* -------------------------------------------------------------------------- *)
(* Consider the hamming distance between two points p and q via a point r.    *)
(* Each change made will modify the result by either 1 or -1. These values    *)
(* are equivalent modulo 2. As a result, the parity of the path between p     *)
(* and q is the same as the parity of the combined paths between p and r and  *)
(* r and q.                                                                   *)
(*                                                                            *)
(* Note: this only works if the elements making up our lists can only take    *)
(* two values. If more than two values are possible, a change can be made     *)
(* which modifies the result by 0, for example, hamming_distance [1] [2]      *)
(* can be changed to hamming_distance [1] [3]. Thus, we need to specify       *)
(* our parameters to the hamming distance as "bool list" instead of "Œ± list"  *)
(* -------------------------------------------------------------------------- *)
Theorem hamming_distance_modeq_2:
  ‚àÄbs cs ds : bool list.
    LENGTH bs = LENGTH cs ‚àß LENGTH cs = LENGTH ds ‚áí
    MODEQ 2 ((hamming_distance bs cs) + (hamming_distance cs ds)) (hamming_distance bs ds)
Proof
  rpt strip_tac
  >> ‚Äò‚àÄbs ds. LENGTH bs = LENGTH cs ‚àß LENGTH cs = LENGTH ds ‚áí MODEQ 2 ((hamming_distance bs cs) + (hamming_distance cs ds)) (hamming_distance bs ds)‚Äô suffices_by gvs[]
  >> rpt $ pop_assum kall_tac
  >> Induct_on ‚Äòcs‚Äô >> rpt strip_tac >> Cases_on ‚Äòbs‚Äô >> Cases_on ‚Äòds‚Äô >> gvs[]
  >> last_x_assum $ qspecl_then [‚Äòt‚Äô, ‚Äòt'‚Äô] assume_tac
  >> Cases_on ‚Äòh = h''‚Äô >> Cases_on ‚Äòh' = h‚Äô >> gvs[MODEQ_DEF]
  >- (qexistsl [‚Äòa‚Äô, ‚Äòb‚Äô] >> gvs[])
  >- (qexistsl [‚Äòa‚Äô, ‚Äòb‚Äô] >> gvs[])
  >- (qexistsl [‚Äòa‚Äô, ‚Äòb‚Äô] >> gvs[])
  >> Cases_on ‚Äòh' = h''‚Äô
  >- (qexistsl [‚Äòa‚Äô, ‚Äòb + 1‚Äô] >> gvs[])
  >> Cases_on ‚Äòh‚Äô >> Cases_on ‚Äòh'‚Äô >> Cases_on ‚Äòh''‚Äô >> gvs[]
QED


Theorem length_n_repetition_code[simp]:
  ‚àÄn bs.
    LENGTH (n_repetition_code n bs) = n * LENGTH bs
Proof
  rpt strip_tac
  >> Induct_on ‚Äòbs‚Äô >> gvs[]
  >> pop_assum kall_tac
  >> PURE_REWRITE_TAC[ADD1]
  >> gvs[]
QED

Theorem n_repetition_code_inj:
  ‚àÄn bs cs.
    LENGTH bs = LENGTH cs ‚àß
    n ‚â† 0 ‚àß
    n_repetition_code n bs = n_repetition_code n cs ‚áí
    bs = cs
Proof
  NTAC 2 strip_tac
  >> Induct_on ‚Äòbs‚Äô >> Cases_on ‚Äòcs‚Äô >> gvs[]
  >> rpt strip_tac
  >> last_x_assum $ qspec_then ‚Äòt‚Äô assume_tac
  >> gvs[]
  >> Cases_on ‚Äòn‚Äô >> gvs[]
QED

(*Theorem is_decoded_nearest_neighbour_n_repetition_code_hamming_distance:
  ‚àÄn m bs cs.
    is_decoded_nearest_neighbour n (n_repetition_code m) bs cs ‚áí
    hamming_distance (n_repetition_code m cs) bs < m * LENGTH bs
Proof
  rpt strip_tac
  >> 
QED*)

Theorem hamming_distance_length:
  ‚àÄbs cs.
    hamming_distance bs cs ‚â§ LENGTH bs
Proof
  strip_tac
  >> gvs[hamming_distance_def]
  >> Induct_on ‚Äòbs‚Äô >> gvs[ZIP_def]
  >> strip_tac
  >> Cases_on ‚Äòcs‚Äô >> gvs[ZIP_def]
  >> pop_assum $ qspec_then ‚Äòt‚Äô assume_tac
  >> Cases_on ‚Äòh = h'‚Äô >> gvs[]                            
QED

Theorem decode_nearest_neighbour_n_repetition_bit_unique:
  ‚àÄn bs cs ds.
    ODD n ‚àß
    bs ‚àà length_n_codes n ‚àß
    is_decoded_nearest_neighbour 1 (n_repetition_code n) bs cs ‚àß
    is_decoded_nearest_neighbour 1 (n_repetition_code n) bs ds ‚áí
    cs = ds
Proof
  rpt strip_tac
  >> ‚Äòdivides n (hamming_distance (n_repetition_code n cs) (n_repetition_code n ds))‚Äô by (irule n_repetition_code_divides >> gs[is_decoded_nearest_neighbour_def])
  >> gs[divides_def]
  >> Cases_on ‚Äòq = 0‚Äô
  >- (qspecl_then [‚Äòn_repetition_code n cs‚Äô, ‚Äòn_repetition_code n ds‚Äô] assume_tac (iffLR $ cj 2 hamming_distance_positivity)
      >> gvs[is_decoded_nearest_neighbour_def]
      >> qspecl_then [‚ÄòLENGTH bs‚Äô, ‚Äòcs‚Äô, ‚Äòds‚Äô] irule n_repetition_code_inj
      >> gvs[]
      >> qexists ‚Äòbs‚Äô
      >> gvs[]
      >> CCONTR_TAC
      >> gvs[])
  >> Cases_on ‚Äòq = 1‚Äô
  >- (gvs[]
      >> gvs[is_decoded_nearest_neighbour_def]
      >> first_assum $ qspec_then ‚Äòcs‚Äô assume_tac
      >> last_assum $ qspec_then ‚Äòds‚Äô assume_tac
      >> qmatch_asmsub_abbrev_tac ‚Äòd1 ‚â§ d2‚Äô
      >> ‚Äòd1 = d2‚Äô by gvs[]
      >> NTAC 2 $ qpat_x_assum ‚Äò_ ‚áí _‚Äô kall_tac
      >> unabbrev_all_tac
      >> gvs[]
      >> qspecl_then [‚Äòn_repetition_code (LENGTH bs) cs‚Äô, ‚Äòbs‚Äô, ‚Äòn_repetition_code (LENGTH bs) ds‚Äô] assume_tac hamming_distance_modeq_2
      >> qmatch_asmsub_abbrev_tac ‚Äòp ‚áí q‚Äô
      >> sg ‚Äòp‚Äô >> unabbrev_all_tac
      >- gvs[]
      >> gvs[]
      >> gvs[hamming_distance_sym]
      >> drule $ iffLR MODEQ_THM >> strip_tac >> gvs[]
      >> gvs[ODD_MOD2_LEM])
  >> qspecl_then [‚Äòn_repetition_code n cs‚Äô, ‚Äòn_repetition_code n ds‚Äô] assume_tac hamming_distance_length
  >> gvs[]
  >> ‚Äòq ‚â§ 1‚Äô by gvs[is_decoded_nearest_neighbour_def]
  >> gvs[]
QED

Theorem hamming_distance_latter_empty:
  ‚àÄbs. hamming_distance bs [] = 0
Proof
  gvs[hamming_distance_def, ZIP_def]
QED

Theorem hamming_distance_former_empty:
  ‚àÄbs. hamming_distance [] bs = 0
Proof
  gvs[hamming_distance_def, ZIP_def]
QED



(* -------------------------------------------------------------------------- *)
(* Broken as a result of removal of donotexpand_tac/doexpand_tac, and not     *)
(* important enought to fix                                                   *)
(* -------------------------------------------------------------------------- *)
(*Theorem is_decoded_nearest_neighbour_cons:
  ‚àÄn bs1 bs2 c cs code_fn.
    ((‚àÄd ds. code_fn (d::ds) = code_fn [d] ‚ß∫ code_fn ds) ‚àß
     code_fn [] = [] ‚àß
     (‚àÄe f. LENGTH (code_fn [e]) = LENGTH (code_fn [f])) ‚àß
     LENGTH bs1 = LENGTH (code_fn [c])
    ) ‚áí
    (is_decoded_nearest_neighbour (SUC n) code_fn (bs1 ‚ß∫ bs2) (c::cs) ‚áî
       is_decoded_nearest_neighbour n code_fn bs2 cs ‚àß
       is_decoded_nearest_neighbour 1 code_fn bs1 [c])
Proof
  rpt strip_tac >> last_x_assum assume_tac >> donotexpand_tac
  >> EQ_TAC
  >- (rpt strip_tac
      >- (gvs[is_decoded_nearest_neighbour_def]
          >> rpt strip_tac
          >- gvs[]
          >> first_x_assum $ qspec_then ‚Äòc::ds‚Äô assume_tac
          >> gvs[]
          >> doexpand_tac
          >> first_assum $ qspecl_then [‚Äòc‚Äô, ‚Äòcs‚Äô] assume_tac
          >> first_x_assum $ qspecl_then [‚Äòc‚Äô, ‚Äòds‚Äô] assume_tac
          >> gvs[])
      >> gvs[is_decoded_nearest_neighbour_def]
      >> rpt strip_tac
      >- gvs[]
      >> first_x_assum $ qspec_then ‚Äò(HD ds)::cs‚Äô assume_tac
      >> gvs[]
      >> doexpand_tac
      >> first_assum $ qspecl_then [‚Äòc‚Äô, ‚Äòcs‚Äô] assume_tac
      >> first_x_assum $ qspecl_then [‚ÄòHD ds‚Äô, ‚Äòcs‚Äô] assume_tac
      >> gvs[]
      >> drule $ iffRL $ cj 2 SING_HD
      >> rpt strip_tac
      >> metis_tac[])
  >> rpt strip_tac
  >> gvs[is_decoded_nearest_neighbour_def]
  >> conj_tac
  >- gvs[]
  >> rpt strip_tac
  >> Cases_on ‚Äòds‚Äô
  >- (doexpand_tac
      >> pop_assum $ qspecl_then [‚ÄòT‚Äô, ‚Äò[]‚Äô] assume_tac
      >> gvs[hamming_distance_latter_empty]
      >> gvs[])
  >> doexpand_tac
  >> first_assum $ qspecl_then [‚Äòc‚Äô, ‚Äòcs‚Äô] assume_tac
  >> first_x_assum $ qspecl_then [‚Äòh‚Äô, ‚Äòt‚Äô] assume_tac
  >> gvs[]
  >> first_x_assum $ qspec_then ‚Äò[h]‚Äô assume_tac
  >> first_x_assum $ qspec_then ‚Äòt‚Äô assume_tac
  >> ‚Äòt ‚àà length_n_codes n‚Äô by gvs[]
  >> ‚Äò[h] ‚àà length_n_codes 1‚Äô by gvs[]
  >> gvs[]
QED*)



(* -------------------------------------------------------------------------- *)
(* Broken because is_decoded_nearest_neighbour_cons is broken, and not        *)
(* important enough to fix                                                    *)
(* -------------------------------------------------------------------------- *)
(*Theorem is_decoded_nearest_neighbour_cons_n_repetition_code:
  ‚àÄn m bs1 bs2 c cs.
    LENGTH bs1 = m ‚áí
    (is_decoded_nearest_neighbour (SUC n) (n_repetition_code m) (bs1 ‚ß∫ bs2) (c::cs) ‚áî
       (is_decoded_nearest_neighbour n (n_repetition_code m) bs2 cs ‚àß
        is_decoded_nearest_neighbour 1 (n_repetition_code m) bs1 [c]))
Proof
  gvs[is_decoded_nearest_neighbour_cons]
QED*)

Theorem length_n_codes_0[simp]:
  ‚àÄbs.
    bs ‚àà length_n_codes 0 ‚áî bs = []
Proof
  rpt strip_tac
  >> EQ_TAC
  >> gvs[]
QED

Theorem is_decoded_nearest_neighbour_0[simp]:
  ‚àÄbs cs code_fn.
    is_decoded_nearest_neighbour 0 code_fn bs cs ‚áî cs = []
Proof
  rpt strip_tac
  >> EQ_TAC
  >> gvs[is_decoded_nearest_neighbour_def] 
QED



(* -------------------------------------------------------------------------- *)
(* Broken because is_decoded_nearest_neighbour_cons_n_repetition_code is      *)
(* broken, and not important enough to fix                                    *)
(* -------------------------------------------------------------------------- *)
(*Theorem decode_nearest_neighbour_n_repetition_code_unique:
  ‚àÄn m bs cs ds.
    ODD m ‚àß
    LENGTH bs = m * LENGTH cs ‚àß
    is_decoded_nearest_neighbour n (n_repetition_code m) bs cs ‚àß
    is_decoded_nearest_neighbour n (n_repetition_code m) bs ds ‚áí
    cs = ds
Proof
  gen_tac
  >> Induct_on ‚Äòn‚Äô >> gvs[]
  >> rpt strip_tac
  >> Cases_on ‚Äòcs‚Äô >> Cases_on ‚Äòds‚Äô >> gvs[]
  >- gvs[is_decoded_nearest_neighbour_def]
  >- gvs[is_decoded_nearest_neighbour_def]
  >> qspecl_then [‚Äòn‚Äô, ‚Äòm‚Äô, ‚ÄòTAKE m bs‚Äô, ‚ÄòDROP m bs‚Äô, ‚Äòh‚Äô, ‚Äòt‚Äô] assume_tac (iffLR is_decoded_nearest_neighbour_cons_n_repetition_code)
  >> gvs[TAKE_DROP]
  >> qspecl_then [‚Äòn‚Äô, ‚Äòm‚Äô, ‚ÄòTAKE m bs‚Äô, ‚ÄòDROP m bs‚Äô, ‚Äòh'‚Äô, ‚Äòt'‚Äô] assume_tac (iffLR is_decoded_nearest_neighbour_cons_n_repetition_code)
  >> gvs[TAKE_DROP]
  >> last_x_assum $ qspecl_then [‚Äòm‚Äô, ‚ÄòDROP m bs‚Äô, ‚Äòt‚Äô, ‚Äòt'‚Äô] assume_tac
  >> gvs[]
  >> gvs[ADD1]
  >> qspecl_then [‚Äòm‚Äô, ‚ÄòTAKE m bs‚Äô, ‚Äò[h]‚Äô, ‚Äò[h']‚Äô] assume_tac decode_nearest_neighbour_n_repetition_bit_unique
  >> gvs[]
  >> pop_assum irule
  >> gvs[]
QED*)

Theorem length_n_codes_sing_hd:
  ‚àÄbs.
    bs ‚àà length_n_codes 1 ‚áî bs = [HD bs]
Proof
  gvs[SING_HD]
QED

Theorem bnot_cons[simp]:
  ‚àÄb bs.
    bnot (b::bs) = (¬¨b)::(bnot bs)
Proof
  gvs[bnot_def]
QED

Theorem hamming_distance_bnot[simp]:
  ‚àÄbs cs.
    LENGTH bs = LENGTH cs ‚áí
    hamming_distance (bnot bs) (bnot cs) = hamming_distance bs cs
Proof
  strip_tac
  >> Induct_on ‚Äòbs‚Äô >> Cases_on ‚Äòcs‚Äô >> gvs[]
  >> rpt strip_tac
  >> last_x_assum $ qspec_then ‚Äòt‚Äô assume_tac
  >> gvs[]
  >> gvs[hamming_distance_cons]
QED

Theorem bitwise_cons[simp]:
  ‚àÄf b bs c cs.
    LENGTH bs = LENGTH cs ‚áí
    bitwise f (b::bs) (c::cs) = (f b c)::(bitwise f bs cs)
Proof
  gvs[bitwise_def]
QED

Theorem bxor_cons[simp]:
  ‚àÄb bs c cs.
    LENGTH bs = LENGTH cs ‚áí
    bxor (b::bs) (c::cs) = (b ‚áé c)::(bxor bs cs)
Proof
  gvs[bxor_def]
QED

Theorem bxor_comm:
  ‚àÄbs cs.
    LENGTH bs = LENGTH cs ‚áí
    bxor bs cs = bxor cs bs
Proof
  strip_tac
  >> Induct_on ‚Äòbs‚Äô >> Cases_on ‚Äòcs‚Äô >> gvs[]
  >> rpt strip_tac
  >- (Cases_on ‚Äòh‚Äô >> Cases_on ‚Äòh'‚Äô >> gvs[])
  >> last_x_assum $ qspec_then ‚Äòt‚Äô assume_tac
  >> gvs[]
QED

Theorem bnot_length[simp]:
  ‚àÄbs.
    LENGTH (bnot bs) = LENGTH bs
Proof
  rpt strip_tac
  >> Induct_on ‚Äòbs‚Äô >> gvs[bnot_def]
QED

Theorem bnot_bxor_1:
  ‚àÄbs cs.
    LENGTH bs = LENGTH cs ‚áí
    bnot (bxor bs cs) = bxor (bnot bs) cs
Proof
  strip_tac
  >> Induct_on ‚Äòbs‚Äô
  >> gvs[bnot_def, bxor_def, bitwise_def]
  >> rpt strip_tac
  >> gvs[bnot_def]
  >> Cases_on ‚Äòcs‚Äô >> gvs[]
  >> Cases_on ‚Äòh‚Äô >> Cases_on ‚Äòh'‚Äô >> gvs[]
QED

Theorem bnot_bxor_2:
  ‚àÄbs cs.
    LENGTH bs = LENGTH cs ‚áí
    bnot (bxor bs cs) = bxor bs (bnot cs)
Proof
  rpt strip_tac
  >> qspecl_then [‚Äòbs‚Äô, ‚Äòbnot cs‚Äô] assume_tac bxor_comm
  >> gvs[]
  >> DEP_PURE_ONCE_REWRITE_TAC[bxor_comm]
  >> gvs[bnot_bxor_1]
QED

Theorem apply_noise_bnot_1:
  ‚àÄns bs.
    LENGTH ns = LENGTH bs ‚áí
    bnot (apply_noise ns bs) = apply_noise (bnot ns) bs
Proof
  gvs[apply_noise_def, bnot_bxor_1]
QED

Theorem apply_noise_bnot_2:
  ‚àÄns bs.
    LENGTH ns = LENGTH bs ‚áí
    bnot (apply_noise ns bs) = apply_noise ns (bnot bs)
Proof
  gvs[apply_noise_def, bnot_bxor_2]
QED

Theorem bnot_n_repetition_bit[simp]:
  ‚àÄn b.
    bnot (n_repetition_bit n b) = n_repetition_bit n (¬¨b)
Proof
  rpt strip_tac
  >> Induct_on ‚Äòn‚Äô >> gvs[bnot_def]
QED

Theorem num_errors_empty[simp]:
  num_errors [] = 0
Proof
  gvs[num_errors_def]
QED

Theorem num_errors_0[simp]:
  ‚àÄns l. ns ‚àà length_n_codes l ‚áí (num_errors ns = 0 ‚áî ns = n_repetition_bit l F)
Proof
  Induct_on ‚Äòl‚Äô >> Cases_on ‚Äòns‚Äô >> gvs[]
  >> rpt strip_tac
  >> first_x_assum $ qspec_then ‚Äòt‚Äô assume_tac
  >> gvs[]
  >> EQ_TAC >> rpt strip_tac >> gvs[num_errors_def]
  >> Cases_on ‚Äòh‚Äô >> gvs[]
QED

Theorem num_errors_cons:
  ‚àÄb bs. num_errors (b::bs) = (if b then 1 else 0) + num_errors bs
Proof
  rw[] >> gvs[num_errors_def]
QED

Theorem num_errors_eq_length:
  ‚àÄbs. num_errors bs = LENGTH bs ‚áî bs = n_repetition_bit (LENGTH bs) T
Proof
  Induct_on ‚Äòbs‚Äô >> gvs[]
  >> rpt strip_tac
  >> gvs[ADD1]
  >> REVERSE $ Cases_on ‚Äòh‚Äô >> gvs[num_errors_cons]
  >> qspec_then ‚Äòbs‚Äô assume_tac num_errors_length
  >> gvs[]
QED

Theorem bxor_empty[simp]:
  bxor [] [] = []
Proof
  EVAL_TAC
QED

Theorem apply_noise_n_repetition_bit_T:
  ‚àÄbs.
    apply_noise (n_repetition_bit (LENGTH bs) T) bs = bnot bs
Proof
  Induct_on ‚Äòbs‚Äô >> gvs[bnot_def, apply_noise_def]
QED

Theorem bnot_empty[simp]:
  bnot [] = []
Proof
  EVAL_TAC
QED

Theorem bnot_append[simp]:
  ‚àÄbs cs.
    bnot (bs ‚ß∫ cs) = bnot bs ‚ß∫ bnot cs
Proof
  Induct_on ‚Äòbs‚Äô >> gvs[]
QED

Theorem n_repetition_code_bnot[simp]:
  ‚àÄbs n.
    n_repetition_code n (bnot bs) = bnot (n_repetition_code n bs)
Proof
  Induct_on ‚Äòn‚Äô >> gvs[]
  >> Induct_on ‚Äòbs‚Äô >> gvs[]
QED

Theorem NOT_IFF[simp]:
  ‚àÄb. (¬¨b ‚áî b) ‚áî F
Proof
  Cases_on ‚Äòb‚Äô >> gvs[]
QED

Theorem hamming_distance_bnot_1[simp]:
  ‚àÄbs.
    hamming_distance (bnot bs) bs = LENGTH bs
Proof
  Induct_on ‚Äòbs‚Äô >> gvs[]
QED

Theorem hamming_distance_bnot_2[simp]:
  ‚àÄbs.
    hamming_distance bs (bnot bs) = LENGTH bs
Proof
  rpt strip_tac
  >> DEP_PURE_ONCE_REWRITE_TAC[hamming_distance_sym]
  >> gvs[]
QED

(* -------------------------------------------------------------------------- *)
(* Broken because exists_decode_nearest_neighbour_candidate is broken, and    *)
(* not important enough to fix                                                *)
(* -------------------------------------------------------------------------- *)
(*Theorem decode_nearest_neighbour_n_repetition_code_3:
  ‚àÄbs ns.
    bs ‚àà length_n_codes 1 ‚àß
    ns ‚àà length_n_codes 3 ‚áí 
    (decode_nearest_neighbour 1 (n_repetition_code 3) (apply_noise ns (n_repetition_code 3 bs)) = bs ‚áî num_errors ns ‚â§ 1)
Proof
  rpt strip_tac
  >> REVERSE EQ_TAC >> disch_tac
  >- (gvs[decode_nearest_neighbour_def]
      >> SELECT_ELIM_TAC
      >> conj_tac
      >- gvs[exists_decode_nearest_neighbour_candidate]
      >> rpt strip_tac
      >> qsuff_tac ‚Äòis_decoded_nearest_neighbour 1 (n_repetition_code 3) (apply_noise ns (n_repetition_code 3 bs)) bs‚Äô
      >- (rpt strip_tac
          >> qspecl_then [‚Äò1‚Äô, ‚Äò3‚Äô, ‚Äòapply_noise ns (n_repetition_code 3 bs)‚Äô, ‚Äòx‚Äô, ‚Äòbs‚Äô] assume_tac decode_nearest_neighbour_n_repetition_code_unique
          >> pop_assum irule
          >> gvs[]
          >> gvs[apply_noise_length]
          >> gvs[]
          >> gvs[is_decoded_nearest_neighbour_def])
      >> pop_assum kall_tac
      >> gvs[is_decoded_nearest_neighbour_def]
      >> rpt strip_tac
      >> Cases_on ‚Äòbs‚Äô >- gvs[]
      >> REVERSE $ Cases_on ‚Äòt‚Äô >- gvs[]
      >> Cases_on ‚Äòds‚Äô >- gvs[]
      >> REVERSE $ Cases_on ‚Äòt‚Äô >- gvs[]
      >> Cases_on ‚Äòh = h'‚Äô >> gvs[]
      >> wlog_tac ‚Äòh = T‚Äô [‚Äòh‚Äô, ‚Äòh'‚Äô]
      >- (first_assum $ qspecl_then [‚Äòh‚Äô, ‚Äòh'‚Äô] assume_tac
          >> gvs[]
          >> DEP_PURE_ONCE_REWRITE_TAC[GSYM hamming_distance_bnot]
          >> rewrite_tac [n_repetition_bit_length, apply_noise_length]
          >> DEP_PURE_ONCE_REWRITE_TAC [apply_noise_bnot_2]
          >> gvs[]
          >> qspecl_then [‚Äòapply_noise ns (n_repetition_bit 3 F)‚Äô, ‚Äòn_repetition_bit 3 T‚Äô] assume_tac (GSYM hamming_distance_bnot)
          >> gvs[apply_noise_length, (Excl "hamming_distance_bnot")]
          >> pop_assum kall_tac
          >> DEP_PURE_ONCE_REWRITE_TAC [apply_noise_bnot_2]
          >> gvs[])
      >> gvs[]
      >> rpt $ qpat_x_assum ‚Äò_ ‚àà length_n_codes 1‚Äô kall_tac
      >> ‚Äòn_repetition_bit 3 T = [T;T;T]‚Äô by EVAL_TAC
      >> ‚Äòn_repetition_bit 3 F = [F;F;F]‚Äô by EVAL_TAC
      >> gvs[]
      >> sg ‚Äònum_errors ns = 0 ‚à® num_errors ns = 1‚Äô >> gvs[]
      >- (drule num_errors_0 >> rpt strip_tac
          >> gvs[]
          >> EVAL_TAC)
      >> Cases_on ‚Äòns‚Äô >> gvs[]
      >> Cases_on ‚Äòt‚Äô >> gvs[]
      >> Cases_on ‚Äòt'‚Äô >> gvs[]
      >> Cases_on ‚Äòt‚Äô >> gvs[]
      >> Cases_on ‚Äòh‚Äô >> gvs[num_errors_def]
      >> Cases_on ‚Äòh'‚Äô >> gvs[num_errors_def]
      >> Cases_on ‚Äòh''‚Äô >> gvs[num_errors_def]
      >> EVAL_TAC)
  >> gvs[decode_nearest_neighbour_def]
  >> sg ‚Äòis_decoded_nearest_neighbour 1 (n_repetition_code 3) (apply_noise ns (n_repetition_code 3 bs)) bs‚Äô
  >- (pop_assum (fn th => assume_tac (GSYM th))
      >> qmatch_goalsub_abbrev_tac ‚ÄòP bs‚Äô
      >> ‚ÄòP @cs. P cs‚Äô by (SELECT_ELIM_TAC >> gvs[Abbr ‚ÄòP‚Äô, exists_decode_nearest_neighbour_candidate])
      >> gvs[])
  >> qpat_x_assum ‚Äò_ = _‚Äô kall_tac
  >> qspec_then ‚Äòns‚Äô assume_tac num_errors_length
  >> gvs[length_n_codes_def]
  >> ‚Äònum_errors ns = 3 ‚à® num_errors ns ‚â§ 2‚Äô by gvs[]
  >- (gvs[]
      >> qspec_then ‚Äòns‚Äô assume_tac num_errors_eq_length
      >> gvs[]
      >> pop_assum kall_tac
      >> gvs[]
      >> qspec_then ‚Äòn_repetition_code 3 bs‚Äô assume_tac apply_noise_n_repetition_bit_T
      >> gvs[]
      >> pop_assum kall_tac
      >> gvs[is_decoded_nearest_neighbour_def]
      >> pop_assum $ qspec_then ‚Äòbnot bs‚Äô assume_tac
      >> gvs[length_n_codes_def])
  >> gvs[n_repetition_code_bnot]
  >> Cases_on ‚Äònum_errors ns = 2‚Äô >> gvs[]
  >> Cases_on ‚Äòns‚Äô >> gvs[]
  >> Cases_on ‚Äòt‚Äô >> gvs[]
  >> Cases_on ‚Äòt'‚Äô >> gvs[]
  >> Cases_on ‚Äòt‚Äô >> gvs[]
  >> gvs[is_decoded_nearest_neighbour_def]
  >> Cases_on ‚Äòbs‚Äô >> gvs[]
  >> first_x_assum $ qspec_then ‚Äò[¬¨h''']‚Äô assume_tac
  >> gvs[length_n_codes_def]
  >> ‚Äòn_repetition_bit 3 T = [T; T; T]‚Äô by EVAL_TAC
  >> ‚Äòn_repetition_bit 3 F = [F; F; F]‚Äô by EVAL_TAC
  >> Cases_on ‚Äòh‚Äô >> Cases_on ‚Äòh'‚Äô >> Cases_on ‚Äòh''‚Äô >> gvs[num_errors_def]
  >> Cases_on ‚Äòh'''‚Äô >> gvs[]
  >> gvs[apply_noise_def]
QED*)

(* -------------------------------------------------------------------------- *)
(* Broken because exists_decode_nearest_neighbour_candidate is broken, and    *)
(* not important enough to fix                                                *)
(* -------------------------------------------------------------------------- *)
(*Theorem decode_nearest_neighbour_is_decoded_nearest_neighbour:
  ‚àÄn code_fn bs.
    is_decoded_nearest_neighbour n code_fn bs (decode_nearest_neighbour n code_fn bs)
Proof
  rpt strip_tac
  >> gvs[decode_nearest_neighbour_def]
  >> SELECT_ELIM_TAC
  >> gvs[exists_decode_nearest_neighbour_candidate]
QED*)

(* -------------------------------------------------------------------------- *)
(* Broken, not important enough to fix                                        *)
(* -------------------------------------------------------------------------- *)
(*Theorem code_decodes_correctly_is_decoded_nearest_neighbour:
  ‚àÄn bs ns code_fn.
    code_decodes_correctly n bs ns code_fn ‚áí is_decoded_nearest_neighbour n code_fn (apply_noise ns (code_fn bs)) bs
Proof
  rpt strip_tac
  >> gvs[code_decodes_correctly_def]
  >> qspecl_then [‚Äòn‚Äô, ‚Äòcode_fn‚Äô, ‚Äòapply_noise ns (code_fn bs)‚Äô] assume_tac decode_nearest_neighbour_is_decoded_nearest_neighbour
  >> gvs[]
QED*)

(* -------------------------------------------------------------------------- *)
(* Broken, not important enough to fix                                        *)
(* -------------------------------------------------------------------------- *)
(*Theorem code_decodes_correctly_n_repetition_code_3:
  ‚àÄbs ns.
    bs ‚àà length_n_codes 1 ‚àß
    ns ‚àà length_n_codes 3 ‚áí
    (code_decodes_correctly 1 bs ns (n_repetition_code 3) ‚áî num_errors ns ‚â§ 1)
Proof
  rpt strip_tac
  >> gvs[code_decodes_correctly_def]
  >> gvs[decode_nearest_neighbour_n_repetition_code_3]
QED*)

fun SUBGOAL_LIST_THEN tms thm_tac final_tac
= case tms of
    [] => final_tac
  | t::ts => SUBGOAL_THEN t (fn th => (thm_tac th >> SUBGOAL_LIST_THEN ts thm_tac final_tac))

fun UNDISCH_ALL_RETURN_TERMS_HELPER (tms : term list) (th : thm) =
let
val (cur_tm, cur_th) = UNDISCH_TM th;
val (rec_tms : term list, rec_th : thm) = UNDISCH_ALL_RETURN_TERMS_HELPER (cur_tm::tms) cur_th;
in
  (rec_tms, rec_th)
  end handle HOL_ERR _ => (tms, th);

fun UNDISCH_ALL_RETURN_TERMS th = UNDISCH_ALL_RETURN_TERMS_HELPER [] th

fun DEP_ASSUME_TAC th
= let
(*val specialised_thm = SPEC_ALL th;*)
val (undischarged_terms, undischarged_thm) = UNDISCH_ALL_RETURN_TERMS th
                                                                      (*val undischarged_thm = UNDISCH_ALL $ SPEC_ALL th;*)
                                                                      (*val uthm_hyps = hyp undischarged_thm;*)
  in
    SUBGOAL_LIST_THEN undischarged_terms assume_tac (assume_tac undischarged_thm)
                      end;

Theorem negation_not_posinf[simp]:
  ‚àÄe. -e ‚â† +‚àû ‚áî e ‚â† ‚àí‚àû
Proof
  rpt strip_tac
  >> EQ_TAC
  >> rpt strip_tac >> gvs[extreal_ainv_def]
  >> Cases_on ‚Äòe‚Äô >> gvs[extreal_ainv_def]
QED

Theorem negation_not_neginf[simp]:
  ‚àÄe. -e ‚â† ‚àí‚àû ‚áî e ‚â† +‚àû
Proof
  rpt strip_tac
  >> EQ_TAC
  >> rpt strip_tac >> gvs[extreal_ainv_def]
  >> Cases_on ‚Äòe‚Äô >> gvs[extreal_ainv_def]
QED

fun dtc' (t : term) =
let val {Thy, Name, ...} = dest_thy_const t in
  SOME (Thy, Name)
       end handle HOL_ERR _ => NONE


                               
(*
fun create_real_expression combinator term_list
                                = case term_list of
                                    t::ts =>
                                  | [] => 
                                      mk_comb combinator

val input_term =  ‚ÄúNormal 3 = Normal 4‚Äù
val input_term = ‚ÄúNormal 3 - Normal 4‚Äù
val input_term = ‚Äú(Normal 1 * Normal 2) + (Normal 3 / Normal 4) + (- Normal 5) - Normal 6 = Normal 7‚Äù
val input_term = ‚Äú(Normal 1 * Normal 2) + (Normal 3 / Normal 4) + (- Normal 5) - Normal 6‚Äù

        
                 mk_comb (mk_comb (‚Äú$+ : real -> real -> real‚Äù, ‚Äú3 : real‚Äù), ‚Äú4 : real‚Äù)

                 dest_comb ‚Äú- 3 : real‚Äù
                 mk_comb (‚Äúnumeric_negate : real -> real‚Äù, ‚Äú3 : real‚Äù)

val input_term = ‚Äú‚àÄr : real. ‚Äù
*)

(*fun extreal_to_real input_term =
                                let
val (combinator, term_list) = strip_comb input_term
val SOME (combinator_theory, combinator_name) = dtc' combinator
val translated_term = case combinator_name of
                        "extreal_add" => mk_comb (mk_comb (‚Äú$+ : real -> real -> real‚Äù, extreal_to_real (el 1 term_list)), extreal_to_real (el 2 term_list))
                      | "extreal_div" => mk_comb (mk_comb (‚Äú$/ : real -> real -> real‚Äù, extreal_to_real (el 1 term_list)), extreal_to_real (el 2 term_list))
                      | "extreal_mul" => mk_comb (mk_comb (‚Äú$* : real -> real -> real‚Äù, extreal_to_real (el 1 term_list)), extreal_to_real (el 2 term_list))
                      | "extreal_ainv" => mk_comb (‚Äúnumeric_negate : real -> real‚Äù, extreal_to_real (el 1 term_list))
                      | "extreal_sub" => mk_comb (mk_comb (‚Äú$- : real -> real -> real‚Äù, extreal_to_real (el 1 term_list)), extreal_to_real (el 2 term_list))
                      | "=" => mk_comb (mk_comb (‚Äú$= : real -> real -> bool‚Äù, extreal_to_real (el 1 term_list)), extreal_to_real (el 2 term_list))
                      (*| "!" => mk_comb (‚Äú!‚Äù, extreal_to_real (hd term_list))*)
                      (*| "?" => mk_comb (‚Äú?‚Äù, extreal_to_real (hd term_list))*)
                      | "Normal" => hd term_list
                      | _ => input_term
                                in
                                  translated_term
                                  end

fun extreal_to_real_equivalence_term input_term =
let
val translated_term = extreal_to_real input_term
in
  mk_comb (mk_comb (‚Äú$= : extreal -> extreal -> bool‚Äù, input_term), mk_comb (‚ÄúNormal‚Äù, translated_term))
          end

fun prove_extreal_to_real input_term =
let 
val
in
  end
                                *)

(*
(* Given an expression of arithmetic operations where each term is of the form
   Normal r for some r, prove that this is equivalent to Normal applied to
   the same expression of arithmetic operations in the reals. *)
fun Normal_CONV input_term =
let
  
val (combinator, term_list) = strip_comb input_term
val SOME (combinator_theory, combinator_name) = dtc' combinator
val translated_term = case combinator_name of
                        "extreal_add" => DECIDE mk_comb (‚Äú$=‚Äù, )  t_term
                      | "extreal_div" => DECIDE ‚ÄúT‚Äù
                      | "extreal_mul" => DECIDE ‚ÄúT‚Äù
                      | "extreal_ainv" => DECIDE ‚ÄúT‚Äù
                      | "extreal_sub" => DECIDE ‚ÄúT‚Äù
                      | ""

                        strip_comb ‚ÄúNormal 2‚Äù
                        
in
  
  (*case combinator_name of
     "!" => DECIDE ‚ÄúT‚Äù
  | "?" => DECIDE ‚ÄúT‚Äù
  | _ => DECIDE ‚ÄúT‚Äù*)
                
  end
                               *)

(*
val Normal_CONV_test1 = ‚Äú‚àÄn : num. ‚àÄr : real. ‚àÉs : real. Normal s + ((- Normal r) pow n) * Normal 2 = Normal 0‚Äù
val Normal_CONV_test2 = ‚ÄúNormal 2 / Normal 3‚Äù
val Normal_CONV_test3 = ‚ÄúNormal 2 + Normal 3‚Äù
val Normal_CONV_test4 = ‚ÄúNormal 2 * Normal 3‚Äù
val Normal_CONV_test5 = ‚Äú-Normal 1‚Äù
val Normal_CONV_test6 = ‚ÄúNormal 2 - Normal 3‚Äù
val Normal_CONV_test7 = ‚Äú‚àÄn : num. Normal 2 pow n = 4‚Äù
val Normal_CONV_test8 = ‚Äú‚àÄr : real. Normal r = 4‚Äù
val Normal_CONV_test9 = ‚Äú‚àÉr : real. Normal r = 4‚Äù

val input_term = ‚ÄúNormal 2 = Normal 3‚Äù

                        
                 dest_comb Normal_CONV_test3
          dest_comb Normal_CONV_test2
          dest_comb Normal_CONV_test1
           snd (dest_comb Normal_CONV_test1)
*)

(* TODO: make this into a reusable simpset *)
val extreal_to_real_simpset_thing = [extreal_add_eq, extreal_mul_eq, cj 3 extreal_ainv_def, cj 1 extreal_pow_def]

Theorem REAL_ADD_RIGHT:
  ‚àÄr1 r2 : real.
    r1 * r2 + r2 = (r1 + 1) * r2
Proof
  rpt strip_tac
  >> gvs[REAL_ADD_RDISTRIB]
QED

(* -------------------------------------------------------------------------- *)
(* Broken, not important enough to fix                                        *)
(* -------------------------------------------------------------------------- *)
(*Theorem REAL_ADD_NEG_RIGHT:
  ‚àÄr1 r2 : real.
    r1 * r2 + -r2 = (r1 - 1) * r2
Proof
  rpt strip_tac
  >> gvs[REAL_ADD_RDISTRIB, real_sub]
  >> gvs[GSYM REAL_NEG_MINUS1]
QED*)

(* -------------------------------------------------------------------------- *)
(* Broken, not important enough to fix                                        *)
(* -------------------------------------------------------------------------- *)
(*((1 - p) pow 2) * (2 * p + 1)*)
(*Theorem q2_sym_prob_correctly_decoded_prob:
  ‚àÄp.
    0 ‚â§ p ‚àß p ‚â§ 1 ‚áí q2_sym_prob_correctly_decoded (p : extreal) = 2 * p pow 3 - 3 * p pow 2 + 1
Proof
  gen_tac
  >> disch_tac
  >> simp[q2_sym_prob_correctly_decoded_def, q2_sym_prob_space_def]
  >> qmatch_goalsub_abbrev_tac ‚Äòmeasure _ s = _‚Äô
  >> sg ‚Äòs = {([T], [F;F;F]); ([F], [F;F;F]); ([T], [T;F;F]); ([F], [T;F;F]); ([T], [F;T;F]); ([F], [F;T;F]); ([T], [F;F;T]); ([F], [F;F;T]);}‚Äô
  >- (unabbrev_all_tac
      >> irule $ iffRL EXTENSION
      >> rpt strip_tac
      >> REVERSE EQ_TAC
      >- (rpt strip_tac
          >> Cases_on ‚Äòx‚Äô
          >> gvs[IN_DEF]
          >> DEP_PURE_ONCE_REWRITE_TAC [code_decodes_correctly_n_repetition_code_3]
          >> EVAL_TAC
          >> gvs[IN_DEF])
      >> rpt strip_tac
      >> gvs[IN_DEF]
      >> gvs[length_n_codes_def]
      >> Cases_on ‚Äòbs‚Äô >> gvs[]
      >> Cases_on ‚Äòns‚Äô >> gvs[]
      >> Cases_on ‚Äòt‚Äô >> gvs[]
      >> Cases_on ‚Äòt'‚Äô >> gvs[]
      >> Cases_on ‚Äòt‚Äô >> gvs[]
      >> qspecl_then [‚Äò[h]‚Äô, ‚Äò[h';h'';h''']‚Äô] assume_tac code_decodes_correctly_n_repetition_code_3
      >> gvs[length_n_codes_def]
      >> pop_assum kall_tac
      >> gvs[num_errors_def]
      >> Cases_on ‚Äòh‚Äô >> Cases_on ‚Äòh'‚Äô >> Cases_on ‚Äòh''‚Äô >> Cases_on ‚Äòh'''‚Äô >> gvs[])
  >> gvs[]
  >> pop_assum kall_tac
  >> qmatch_goalsub_abbrev_tac ‚Äòmeasure _ s = _‚Äô
  >> sg ‚Äòs = {[T]; [F]} √ó {[F; F; F]; [T; F; F]; [F; T; F]; [F; F; T]}‚Äô
  >- (unabbrev_all_tac
      >> EVAL_TAC)
  >> gvs[]
  >> pop_assum kall_tac
  >> qmatch_goalsub_abbrev_tac ‚Äòmeasure (m0 √ó m1) (s0 √ó s1) = _‚Äô
  >> qmatch_goalsub_abbrev_tac ‚Äò_ = RHS‚Äô
  >> qsuff_tac ‚Äòmeasure m0 s0 = 1 ‚àß measure m1 s1 = RHS‚Äô
  >- (rpt strip_tac
      >> DEP_PURE_ONCE_REWRITE_TAC[prod_measure_cross]
      >> gvs[]
      >> unabbrev_all_tac
      >> conj_tac
      >- metis_tac[prob_space_def, length_n_codes_uniform_prob_space_is_prob_space]
      >> conj_tac
      >- metis_tac[prob_space_def, sym_noise_prob_space_is_prob_space]
      >> conj_tac
      >> gvs[measurable_sets_def, length_n_codes_uniform_prob_space_def, POW_DEF, length_n_codes_def, sym_noise_prob_space_def])
  >> conj_tac
  >- (unabbrev_all_tac
      >> EVAL_TAC
      >> sg ‚Äò{c | LENGTH c = 1} = {[T]; [F;]}‚Äô
      >- (irule $ iffRL EXTENSION
          >> rpt strip_tac
          >> Cases_on ‚Äòx‚Äô >> gvs[]
          >> Cases_on ‚Äòh‚Äô >> gvs[])
      >> gvs[]
      >> qspec_then ‚ÄòNormal 2‚Äô assume_tac div_refl
      >> gvs[])
  >> unabbrev_all_tac
  >> gvs[sym_noise_prob_space_def, sym_noise_dist_def, sym_noise_mass_func_def]
  >> qmatch_goalsub_abbrev_tac ‚Äò‚àë f (x1 INSERT x2 INSERT x3 INSERT x4 INSERT s)‚Äô
  >> sg ‚Äò‚àÄx. f x ‚â† +‚àû‚Äô
  >- (gen_tac
      >> unabbrev_all_tac
      >> gvs[]
      >> irule (cj 2 mul_not_infty2)
      >> sg ‚Äòp ‚â† ‚àí‚àû ‚àß p ‚â† +‚àû‚Äô
      >- (gvs[pos_not_neginf]
          >> irule le_not_posinf
          >> qexists ‚Äò1‚Äô
          >> gvs[])
      >> NTAC 2 (last_x_assum kall_tac)
      >> ‚Äò1 - p ‚â† ‚àí‚àû ‚àß 1 - p ‚â† +‚àû‚Äô by gvs[sub_not_infty]
      >> gvs[pow_not_infty])
  >> ‚ÄòFINITE s‚Äô by (unabbrev_all_tac >> EVAL_TAC)
  >> NTAC 4 (DEP_PURE_ONCE_REWRITE_TAC [EXTREAL_SUM_IMAGE_INSERT]
             >> gvs[]
             >> DEP_PURE_ONCE_REWRITE_TAC[iffLR DELETE_NON_ELEMENT]
             >> conj_tac >- (unabbrev_all_tac >> gvs[]))
  >> unabbrev_all_tac
  >> gvs[]
  >> EVAL_TAC
  >> gvs[pow_0]
  >> pop_assum kall_tac
  >> qmatch_goalsub_abbrev_tac ‚ÄòLHS = RHS‚Äô
  >> Cases_on ‚Äòp‚Äô >> gvs[]
  >> gvs[extreal_add_eq, extreal_mul_eq, cj 3 extreal_ainv_def, cj 1 extreal_pow_def]
  >> Cases_on ‚ÄòLHS‚Äô >> gvs[]
  >- (unabbrev_all_tac >> gvs[]
      (*>> PURE_REWRITE_TAC[GSYM (EVAL ‚ÄúSUC 2‚Äù)]
                              >> PURE_REWRITE_TAC[GSYM (EVAL ‚ÄúSUC 1‚Äù)]
                              >> PURE_REWRITE_TAC[GSYM (EVAL ‚ÄúSUC 0‚Äù)]
                              >> PURE_REWRITE_TAC[real_pow]
                              >> gvs[]
                              >> gvs[REAL_ADD_LDISTRIB, REAL_ADD_RDISTRIB]
                              >> gvs[REAL_NEG_MUL2]
                  >> gvs[REAL_ADD_ASSOC]
      >> gvs[REAL_MUL_RNEG, GSYM REAL_MUL_LNEG]
      >> gvs[REAL_MUL_ASSOC]
      >> gvs[REAL_MUL_RNEG, GSYM REAL_MUL_LNEG]
      >> gvs[AC REAL_ADD_COMM REAL_ADD_ASSOC]
      >> gvs[GSYM REAL_NEG_LMUL]
      >> gvs[REAL_DOUBLE]
      >> gvs[REAL_ADD_ASSOC]
      >> gvs[REAL_DOUBLE]
      >> gvs[REAL_ADD_RIGHT, REAL_ADD_NEG_RIGHT]
      >> gvs[real_sub]*)
  >> REAL_ARITH_TAC)
QED*)



(* 50% chance of 1, 50% chance of 0 *)
(* code_fn encodes this into 111 or 000 *)
(* symmetric noise corrupts this *)
(* decoded using nearest neighbour method. *)
(* probability of the result being correct*)
(*Theorem 

Proof
QED*)

(*Theorem :
  ‚àÄn p bs.
    (measure (sym_err_chan_prob_space n p bs))
Proof
QED*)

val _ = export_theory();

