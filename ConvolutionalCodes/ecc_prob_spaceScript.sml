(* Written by Eric Hall, under the guidance of Michael Norrish *)

open HolKernel Parse boolLib bossLib;

open probabilityTheory;

val _ = new_theory "ecc_prob_space";

(* -------------------------------------------------------------------------- *)
(* Some of these concepts were moved here from Practice/block_codesScript.sml,*)
(* which may still contain useful theorems, etc.                              *)
(* -------------------------------------------------------------------------- *)

Overload length_n_codes = “λn. {c : bool list | LENGTH c = n}”;

(* -------------------------------------------------------------------------- *)
(* A uniform distribution on the possible binary strings of length n.         *)
(*                                                                            *)
(* We expect the initial message that was sent to have this kind of           *)
(* distribution. If this were not the case, then we would be able to compress *)
(* the message further using the patterns in the data, until eventually we    *)
(* get to a point where the only information remaining is a series of         *)
(* completely random bits.                                                    *)
(*                                                                            *)
(* n: the length of the binary string                                         *)
(* -------------------------------------------------------------------------- *)
Definition uniform_binary_string_prob_space_def:
  uniform_binary_string_prob_space (n : num) =
  let s = length_n_codes n in
    let a = POW s in
      let p = uniform_distribution (s, a) in
        (s, a, p)
End

(* -------------------------------------------------------------------------- *)
(* The probability mass function of a sequence of errors applied by a binary  *)
(* symmetric channel.                                                         *)
(*                                                                            *)
(* p: the probability of an error being applied to a given bit                *)
(* bs: the bitstring of errors                                                *)
(* -------------------------------------------------------------------------- *)
Definition sym_noise_mass_func_def:
  sym_noise_mass_func (p : extreal) [] = Normal 1 ∧
  sym_noise_mass_func (p : extreal) (b::bs) =
  (if b then p else 1 - p) * sym_noise_mass_func p bs
End

(* -------------------------------------------------------------------------- *)
(* The probability distribution over possible errors caused by binary         *)
(* symmetric channel.                                                         *)
(*                                                                            *)
(* p: the probability of an error being applied to a given bit                *)
(* e (implicit): the event to find the probability for. An event is a set of  *)
(*               possible error patterns.                                     *)
(*                                                                            *)
(* Output: the probability of the given event.                                *)
(* -------------------------------------------------------------------------- *)
Definition sym_noise_dist_def:
  sym_noise_dist (p : extreal) = ∑ (sym_noise_mass_func p)
End

(* -------------------------------------------------------------------------- *)
(* The probability space of possible error patterns generated by a binary     *)
(* symmetric channel.                                                         *)
(*                                                                            *)
(* n: the length of the error pattern                                         *)
(* p: the probability of an error                                             *)
(* -------------------------------------------------------------------------- *)
Definition sym_noise_prob_space_def:
  sym_noise_prob_space (n : num) (p : extreal)  =
  let sample_space = length_n_codes n in
    let event_space = POW sample_space in
      let prob_dist = sym_noise_dist p in
        (sample_space, event_space, prob_dist)
End



val _ = export_theory();
