(* Written by Eric Hall *)

open HolKernel Parse boolLib bossLib;

val _ = new_theory "thingsToDiscuss";

(*                                                                            *)

(* -------------------------------------------------------------------------- *)
(* MIT lectures on convolutional codes                                        *)
(* -------------------------------------------------------------------------- *)
(* Content:                                                                   *)
(*                                                                            *)
(* A sliding window is moved over the input (this is why the code is called   *)
(* convolutional). At each position a number of parity bits are generated.    *)
(* These parity bits comprise the output.                                     *)
(*                                                                            *)
(* The constraint length K denotes the size of the sliding window             *)
(*                                                                            *)
(* If r bits are generated at each position, then the output will be r times  *)
(* the size of the original, and the code rate will be 1/r, as 1 bit of the   *)
(* original message is transmitted per r bits of the encoded message.         *)
(*                                                                            *)
(* In a given window, the parity bits are generated using partity equations,  *)
(* which are polynomials over the elements of the window, in modulo 2.        *)
(*                                                                            *)
(* Convolutional coding can be viewed in terms of a block diagram, which      *)
(* effectively interprets the algorithm in the aforementioned way, as outputs *)
(* generated from polynomials                                                 *)
(*                                                                            *)
(* It can also be viewed from a state machine perspective, where each state   *)
(* represents the past few perceived bits, and each transition refers to the  *)
(* bit that was read in this state and the bits that were output in this      *)
(* state, as the polynomials will always output the same bit if they are in   *)
(* the same state.                                                            *)
(*                                                                            *)
(* Typically starts from the state which perceived two zeros beforehand       *)
(*                                                                            *)
(* The above is sufficient for encoding                                       *)
(*                                                                            *)
(* Decoding through maximum likelihood decoding. This is equivalent to        *)
(* finding the nearest valid codeword in terms of Hamming distance.           *)
(*                                                                            *)
(* The trellis is a structure that contains the state at each time step,      *)
(* and transitions from states at each time step to the corresponding states  *)
(* at the next time step. Basically adds time information to the state        *)
(* machine.                                                                   *)
(*                                                                            *)
(* Hard decision decoding is basically digital whereas soft decision decoding *)
(* is basically analog. This algorithm is typically implemented on the        *)
(* circuit level, where we have voltages rather than binary 1s and 0s. Soft   *)
(* decoding improves error correcting performance.                            *)
(*                                                                            *)
(* Want to find a path through the trellis that most closely approximates the *)
(* received message.                                                          *)
(*                                                                            *)
(* Branch metric: Hamming distance between output of a particular transition  *)
(* and the received message at that point.                                    *)
(*                                                                            *)
(* Path metric: the minimum sum of branch metrics on any path in order to get *)
(* to a particular state.                                                     *)
(*                                                                            *)
(* The Viterbi algorithm basically just applies dynamic programming to the    *)
(* trellis in order to minimize the path metric at each state and time. The   *)
(* path metric of any state at a given time is dependent on and only on the   *)
(* path metrics of all states at the previous point in time.                  *)
(*                                                                            *)
(* Downside: decoding time exponential in K, the constraint length            *)
(*                                                                            *)
(* Downside: decoding time for first bit requires the entire path to be built *)
(*                                                                            *)
(* In practice, starting decoding at 5 * K bits is a reasonable decoding      *)
(* window, because beyond this point it's unlikely for further future         *)
(* knowledge to affect the optimal first move on the path                     *)
(*                                                                            *)
(* My own observation: surely at some point, the optimal first move will be   *)
(* optimal on a path towards each state, and at that point you could take     *)
(* that step confidently?                                                     *)
(*                                                                            *)
(* BCJR or Fano's sequential decoding scheme may be used to decode for large  *)
(* K.                                                                         *)
(* -------------------------------------------------------------------------- *)
(* Questions/things to discuss:                                               *)
(*                                                                            *)
(* Using analog encoding gives better performance than using digital encoding.*)
(* Should I use analog encoding?                                              *)
(*                                                                            *)
(* Relatedly, often implemented on the circuit level. Should I implement on   *)
(* circuit level.                                                             *)
(*                                                                            *)
(*                                                                            *)
(*                                                                            *)
(* -------------------------------------------------------------------------- *)

(* -------------------------------------------------------------------------- *)
(* Paper on formally verified ACL2 convolutional codes                        *)
(* -------------------------------------------------------------------------- *)
(* Content:                                                                   *)

(* Read the ACL2 paper, see notes                                             *)
(* Based explicitly on another paper, combinatorial method                    *)
(* What is meant by combinatorial method? When considering convolutional algorithm. *)
(* -------------------------------------------------------------------------- *)

(* One of the things I picked up on *)

(* Convolutional coding in paper *)

(* Paper cited by ACL2 paper *)


val _ = export_theory();


